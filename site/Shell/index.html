



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="A Material Design theme for MyNotes">
      
      
      
        <meta name="author" content="Anonymous">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../images/favicon.ico">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.0.1">
    
    
      
        <title>Shell - Material Design for MyNotes</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.982221ab.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.224b79ff.css">
      
      
        
        
        <meta name="theme-color" content="#4caf50">
      
    
    
      <script src="../assets/javascripts/modernizr.1f0bcf2b.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
      <link rel="manifest" href="../manifest.webmanifest">
    
    
    
      
        
<script>
  window.ga = window.ga || function() {
    (ga.q = ga.q || []).push(arguments)
  }
  ga.l = +new Date
  /* Setup integration and send page view */
  ga("create", "UA-131093963-1", "auto")
  ga("set", "anonymizeIp", true)
  ga("send", "pageview")
  /* Register handler to log search on blur */
  document.addEventListener("DOMContentLoaded", () => {
    if (document.forms.search) {
      var query = document.forms.search.query
      query.addEventListener("blur", function() {
        if (this.value) {
          var path = document.location.pathname;
          ga("send", "pageview", path + "?q=" + this.value)
        }
      })
    }
  })
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="green" data-md-color-accent="light-green">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#shell" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href=".." title="Material Design for MyNotes" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Material Design for MyNotes
            </span>
            <span class="md-header-nav__topic">
              Shell
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/Black-Gold/MyNotes/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Black-Gold/MyNotes
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href=".." title="Material Design for MyNotes" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    Material Design for MyNotes
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/Black-Gold/MyNotes/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Black-Gold/MyNotes
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../Vim/" title="Vim" class="md-nav__link">
      Vim
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      ProgramLanguages
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        ProgramLanguages
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../BREs/" title="BREs" class="md-nav__link">
      BREs
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Shell
      </label>
    
    <a href="./" title="Shell" class="md-nav__link md-nav__link--active">
      Shell
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#shell_1" title="shell特殊变量基本解释" class="md-nav__link">
    shell特殊变量基本解释
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell_2" title="在shell中常用的特殊符号罗列如下：" class="md-nav__link">
    在shell中常用的特殊符号罗列如下：
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#command-separator" title="; 分号 (Command separator)" class="md-nav__link">
    ; 分号 (Command separator)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#terminator" title=";; 连续分号 (Terminator)" class="md-nav__link">
    ;; 连续分号 (Terminator)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dot" title=". 逗号 (dot,就是“点”)" class="md-nav__link">
    . 逗号 (dot,就是“点”)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string-single-quote" title="'string' 单引号 (single quote)" class="md-nav__link">
    'string' 单引号 (single quote)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string-double-quote" title="\"string" 双引号 (double quote)" class="md-nav__link">
    \"string" 双引号 (double quote)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#96command-backticks" title="`command` 倒引号 (backticks)" class="md-nav__link">
    `command` 倒引号 (backticks)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comma" title=", 逗点 (comma，标点中的逗号)" class="md-nav__link">
    , 逗点 (comma，标点中的逗号)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#forward-slash" title="/ 斜线 (forward slash)" class="md-nav__link">
    / 斜线 (forward slash)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#9232" title="\ 倒斜线" class="md-nav__link">
    \ 倒斜线
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pipeline" title="| 管道 (pipeline)" class="md-nav__link">
    | 管道 (pipeline)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#negate-or-reverse" title="! 惊叹号(negate or reverse)" class="md-nav__link">
    ! 惊叹号(negate or reverse)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_1" title=": 冒号" class="md-nav__link">
    : 冒号
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wild-card" title="? 问号 (wild card)" class="md-nav__link">
    ? 问号 (wild card)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wild-card_1" title="* 星号 (wild card)" class="md-nav__link">
    * 星号 (wild card)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" title="** 次方运算" class="md-nav__link">
    ** 次方运算
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dollardollar-sign" title="$ dollar符号(dollar sign)" class="md-nav__link">
    $ dollar符号(dollar sign)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" title="${} 变量的正规表达式" class="md-nav__link">
    ${} 变量的正规表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" title="$*符号" class="md-nav__link">
    $*符号
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" title="$@" class="md-nav__link">
    $@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#status-variable" title="$? 状态值 (status variable)" class="md-nav__link">
    $? 状态值 (status variable)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" title="$$" class="md-nav__link">
    $$
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#command-group" title="(   ) 指令群组 (command group)" class="md-nav__link">
    (   ) 指令群组 (command group)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" title="(( ))" class="md-nav__link">
    (( ))
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block-of-code" title="{ } 大括号 (Block of code)" class="md-nav__link">
    { } 大括号 (Block of code)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" title="[ ] 中括号" class="md-nav__link">
    [ ] 中括号
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" title="[[ ]]" class="md-nav__link">
    [[ ]]
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-or" title="|| 逻辑符号----代表 or 逻辑的符号。" class="md-nav__link">
    || 逻辑符号----代表 or 逻辑的符号。
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-and" title="&amp;&amp; 逻辑符号----代表 and 逻辑的符号。" class="md-nav__link">
    &amp;&amp; 逻辑符号----代表 and 逻辑的符号。
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" title="&amp; 后台工作" class="md-nav__link">
    &amp; 后台工作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#9292" title="\&lt;...\&gt; 单字边界" class="md-nav__link">
    \&lt;...\&gt; 单字边界
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plus" title="+ 加号 (plus)" class="md-nav__link">
    + 加号 (plus)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-dash" title="- 减号 (dash)" class="md-nav__link">
    - 减号 (dash)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modulo" title="% 除法 (Modulo)" class="md-nav__link">
    % 除法 (Modulo)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#equals" title="= 等号 (Equals)" class="md-nav__link">
    = 等号 (Equals)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#equals_1" title="== 等号 (Equals)" class="md-nav__link">
    == 等号 (Equals)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" title="!= 不等于" class="md-nav__link">
    != 不等于
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-" title="-" class="md-nav__link">
    -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" title="~" class="md-nav__link">
    ~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" title="~+" class="md-nav__link">
    ~+
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_1" title="~-" class="md-nav__link">
    ~-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" title="控制字符" class="md-nav__link">
    控制字符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell_3" title="shell多行注释实现方式" class="md-nav__link">
    shell多行注释实现方式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" title="变量替换" class="md-nav__link">
    变量替换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bash" title="bash变量是无类型的" class="md-nav__link">
    bash变量是无类型的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" title="特殊变量类型" class="md-nav__link">
    特殊变量类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" title="转义字符" class="md-nav__link">
    转义字符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bash_1" title="bash退出和退出状态" class="md-nav__link">
    bash退出和退出状态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#if" title="和if一起使用的主要表达式" class="md-nav__link">
    和if一起使用的主要表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#if_1" title="if语句[ ] [[ ]]比较" class="md-nav__link">
    if语句[ ] [[ ]]比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ifthenelse" title="if/then/else构造" class="md-nav__link">
    if/then/else构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#then" title="then语句后面的命令" class="md-nav__link">
    then语句后面的命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" title="其他比较操作符" class="md-nav__link">
    其他比较操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fithen" title="嵌套的fi/then条件语句" class="md-nav__link">
    嵌套的fi/then条件语句
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" title="操作符" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" title="数字常量" class="md-nav__link">
    数字常量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#readechoprintf" title="read内置命令是echo和printf命令的对应命令" class="md-nav__link">
    read内置命令是echo和printf命令的对应命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sedawkgrep" title="sed&amp;awk&amp;grep" class="md-nav__link">
    sed&amp;awk&amp;grep
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" title="文本间隔：" class="md-nav__link">
    文本间隔：
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" title="编号：" class="md-nav__link">
    编号：
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_23" title="文本转换和替代：" class="md-nav__link">
    文本转换和替代：
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_24" title="选择性地显示特定行：" class="md-nav__link">
    选择性地显示特定行：
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_25" title="选择性地删除特定行：" class="md-nav__link">
    选择性地删除特定行：
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_26" title="特殊应用：" class="md-nav__link">
    特殊应用：
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Python3/" title="Python3" class="md-nav__link">
      Python3
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Lua/" title="Lua" class="md-nav__link">
      Lua
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Go/" title="Go" class="md-nav__link">
      Go
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      AboutLinux
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        AboutLinux
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Linux/" title="Linux" class="md-nav__link">
      Linux
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Utilities/" title="Iproute2&Net-tools" class="md-nav__link">
      Iproute2&Net-tools
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Iptables/" title="Iptables" class="md-nav__link">
      Iptables
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Firewalld/" title="Firewalld" class="md-nav__link">
      Firewalld
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      DevOps
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        DevOps
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Ansible/" title="Ansible" class="md-nav__link">
      Ansible
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Apollo/" title="Apollo" class="md-nav__link">
      Apollo
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      WebServer
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        WebServer
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Nginx/" title="Nginx" class="md-nav__link">
      Nginx
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Apache/" title="Apache&PHP-FPM" class="md-nav__link">
      Apache&PHP-FPM
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Tomcat/" title="Tomcat" class="md-nav__link">
      Tomcat
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../WildFly.md" title="WildFly" class="md-nav__link">
      WildFly
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Caddy/" title="Caddy" class="md-nav__link">
      Caddy
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      OptimisingWebDelivery
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        OptimisingWebDelivery
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Squid/" title="Squid" class="md-nav__link">
      Squid
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Varnish/" title="Varnish" class="md-nav__link">
      Varnish
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Stunnel/" title="Stunnel" class="md-nav__link">
      Stunnel
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../TrafficServer/" title="ApacheTrafficServer" class="md-nav__link">
      ApacheTrafficServer
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-8" type="checkbox" id="nav-8">
    
    <label class="md-nav__link" for="nav-8">
      CI&DC
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-8">
        CI&DC
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Git/" title="Git&GitLab" class="md-nav__link">
      Git&GitLab
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Jenkins/" title="Jenkins" class="md-nav__link">
      Jenkins
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-9" type="checkbox" id="nav-9">
    
    <label class="md-nav__link" for="nav-9">
      Database
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-9">
        Database
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../MySQL/" title="MySQL" class="md-nav__link">
      MySQL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../MariaDB/" title="MariaDB" class="md-nav__link">
      MariaDB
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Oracle/" title="Oracle" class="md-nav__link">
      Oracle
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Redis/" title="Redis" class="md-nav__link">
      Redis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Memcached/" title="Memcached" class="md-nav__link">
      Memcached
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../MongoDB/" title="MongoDB" class="md-nav__link">
      MongoDB
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../PostgreSQL/" title="PostgreSQL" class="md-nav__link">
      PostgreSQL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Cassandra/" title="Cassandra" class="md-nav__link">
      Cassandra
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-10" type="checkbox" id="nav-10">
    
    <label class="md-nav__link" for="nav-10">
      Monitor
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-10">
        Monitor
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Zabbix/" title="Zabbix" class="md-nav__link">
      Zabbix
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Prometheus/" title="Prometheus" class="md-nav__link">
      Prometheus
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Grafana/" title="Grafana" class="md-nav__link">
      Grafana
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Elk/" title="ELKStack" class="md-nav__link">
      ELKStack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Nagios/" title="Nagios" class="md-nav__link">
      Nagios
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../TICK/" title="TICKStack" class="md-nav__link">
      TICKStack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../OpenTSDB/" title="OpenTSDB" class="md-nav__link">
      OpenTSDB
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Monitors/" title="SomelseMonitors" class="md-nav__link">
      SomelseMonitors
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-11" type="checkbox" id="nav-11">
    
    <label class="md-nav__link" for="nav-11">
      LB&HA
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-11">
        LB&HA
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../LVSKeepalived/" title="LVSKeepalived" class="md-nav__link">
      LVSKeepalived
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Haproxy/" title="HAProxy" class="md-nav__link">
      HAProxy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Traefik/" title="Traefik" class="md-nav__link">
      Traefik
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Envoy/" title="Envoy" class="md-nav__link">
      Envoy
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-12" type="checkbox" id="nav-12">
    
    <label class="md-nav__link" for="nav-12">
      ContainerEcosystem
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-12">
        ContainerEcosystem
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Docker/" title="Docker" class="md-nav__link">
      Docker
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Kubernetes/" title="Kubernetes" class="md-nav__link">
      Kubernetes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../OKD/" title="OKD" class="md-nav__link">
      OKD
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Coreos/" title="ContainerOS" class="md-nav__link">
      ContainerOS
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-13" type="checkbox" id="nav-13">
    
    <label class="md-nav__link" for="nav-13">
      MessageQueue
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-13">
        MessageQueue
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../ActiveMQ/" title="ActiveMQ" class="md-nav__link">
      ActiveMQ
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../ActiveMQApollo/" title="ActiveMQ Apollo" class="md-nav__link">
      ActiveMQ Apollo
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Kafka/" title="Kafka" class="md-nav__link">
      Kafka
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../RabbitMQ/" title="RabbitMQ" class="md-nav__link">
      RabbitMQ
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-14" type="checkbox" id="nav-14">
    
    <label class="md-nav__link" for="nav-14">
      FileSystem
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-14">
        FileSystem
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Ceph/" title="Ceph" class="md-nav__link">
      Ceph
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../GlusterFS/" title="GlusterFS" class="md-nav__link">
      GlusterFS
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Vsftp/" title="Vsftp" class="md-nav__link">
      Vsftp
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-15" type="checkbox" id="nav-15">
    
    <label class="md-nav__link" for="nav-15">
      Security
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-15">
        Security
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Snort/" title="Snort" class="md-nav__link">
      Snort
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-16" type="checkbox" id="nav-16">
    
    <label class="md-nav__link" for="nav-16">
      Network
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-16">
        Network
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Cisco/" title="Cisco" class="md-nav__link">
      Cisco
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Huawei/" title="Huawei" class="md-nav__link">
      Huawei
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../DNS/" title="DNS" class="md-nav__link">
      DNS
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Mail/" title="Mail" class="md-nav__link">
      Mail
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Samba/" title="Samba" class="md-nav__link">
      Samba
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-17" type="checkbox" id="nav-17">
    
    <label class="md-nav__link" for="nav-17">
      CrossGFW
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-17">
        CrossGFW
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../VPN/" title="VPN" class="md-nav__link">
      VPN
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Shadowsocks/" title="Shadowsocks" class="md-nav__link">
      Shadowsocks
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-18" type="checkbox" id="nav-18">
    
    <label class="md-nav__link" for="nav-18">
      TreasureTheLeisure
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-18">
        TreasureTheLeisure
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../GoogleTricks/" title="GoogleTricks" class="md-nav__link">
      GoogleTricks
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Freeswitch/" title="Freeswitch" class="md-nav__link">
      Freeswitch
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Asterisk/" title="Asterisk" class="md-nav__link">
      Asterisk
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Sipcode/" title="Sipcode" class="md-nav__link">
      Sipcode
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Raspberrypi/" title="Raspberrypi" class="md-nav__link">
      Raspberrypi
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Windows/" title="Windows" class="md-nav__link">
      Windows
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#shell_1" title="shell特殊变量基本解释" class="md-nav__link">
    shell特殊变量基本解释
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shell_2" title="在shell中常用的特殊符号罗列如下：" class="md-nav__link">
    在shell中常用的特殊符号罗列如下：
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#command-separator" title="; 分号 (Command separator)" class="md-nav__link">
    ; 分号 (Command separator)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#terminator" title=";; 连续分号 (Terminator)" class="md-nav__link">
    ;; 连续分号 (Terminator)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dot" title=". 逗号 (dot,就是“点”)" class="md-nav__link">
    . 逗号 (dot,就是“点”)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string-single-quote" title="'string' 单引号 (single quote)" class="md-nav__link">
    'string' 单引号 (single quote)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string-double-quote" title="\"string" 双引号 (double quote)" class="md-nav__link">
    \"string" 双引号 (double quote)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#96command-backticks" title="`command` 倒引号 (backticks)" class="md-nav__link">
    `command` 倒引号 (backticks)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comma" title=", 逗点 (comma，标点中的逗号)" class="md-nav__link">
    , 逗点 (comma，标点中的逗号)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#forward-slash" title="/ 斜线 (forward slash)" class="md-nav__link">
    / 斜线 (forward slash)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#9232" title="\ 倒斜线" class="md-nav__link">
    \ 倒斜线
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pipeline" title="| 管道 (pipeline)" class="md-nav__link">
    | 管道 (pipeline)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#negate-or-reverse" title="! 惊叹号(negate or reverse)" class="md-nav__link">
    ! 惊叹号(negate or reverse)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_1" title=": 冒号" class="md-nav__link">
    : 冒号
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wild-card" title="? 问号 (wild card)" class="md-nav__link">
    ? 问号 (wild card)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wild-card_1" title="* 星号 (wild card)" class="md-nav__link">
    * 星号 (wild card)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" title="** 次方运算" class="md-nav__link">
    ** 次方运算
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dollardollar-sign" title="$ dollar符号(dollar sign)" class="md-nav__link">
    $ dollar符号(dollar sign)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" title="${} 变量的正规表达式" class="md-nav__link">
    ${} 变量的正规表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" title="$*符号" class="md-nav__link">
    $*符号
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" title="$@" class="md-nav__link">
    $@
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#status-variable" title="$? 状态值 (status variable)" class="md-nav__link">
    $? 状态值 (status variable)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" title="$$" class="md-nav__link">
    $$
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#command-group" title="(   ) 指令群组 (command group)" class="md-nav__link">
    (   ) 指令群组 (command group)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" title="(( ))" class="md-nav__link">
    (( ))
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block-of-code" title="{ } 大括号 (Block of code)" class="md-nav__link">
    { } 大括号 (Block of code)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" title="[ ] 中括号" class="md-nav__link">
    [ ] 中括号
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" title="[[ ]]" class="md-nav__link">
    [[ ]]
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-or" title="|| 逻辑符号----代表 or 逻辑的符号。" class="md-nav__link">
    || 逻辑符号----代表 or 逻辑的符号。
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-and" title="&amp;&amp; 逻辑符号----代表 and 逻辑的符号。" class="md-nav__link">
    &amp;&amp; 逻辑符号----代表 and 逻辑的符号。
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" title="&amp; 后台工作" class="md-nav__link">
    &amp; 后台工作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#9292" title="\&lt;...\&gt; 单字边界" class="md-nav__link">
    \&lt;...\&gt; 单字边界
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plus" title="+ 加号 (plus)" class="md-nav__link">
    + 加号 (plus)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-dash" title="- 减号 (dash)" class="md-nav__link">
    - 减号 (dash)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modulo" title="% 除法 (Modulo)" class="md-nav__link">
    % 除法 (Modulo)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#equals" title="= 等号 (Equals)" class="md-nav__link">
    = 等号 (Equals)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#equals_1" title="== 等号 (Equals)" class="md-nav__link">
    == 等号 (Equals)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" title="!= 不等于" class="md-nav__link">
    != 不等于
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-" title="-" class="md-nav__link">
    -
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" title="~" class="md-nav__link">
    ~
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" title="~+" class="md-nav__link">
    ~+
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_1" title="~-" class="md-nav__link">
    ~-
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" title="控制字符" class="md-nav__link">
    控制字符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell_3" title="shell多行注释实现方式" class="md-nav__link">
    shell多行注释实现方式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" title="变量替换" class="md-nav__link">
    变量替换
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bash" title="bash变量是无类型的" class="md-nav__link">
    bash变量是无类型的
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" title="特殊变量类型" class="md-nav__link">
    特殊变量类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" title="转义字符" class="md-nav__link">
    转义字符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bash_1" title="bash退出和退出状态" class="md-nav__link">
    bash退出和退出状态
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#if" title="和if一起使用的主要表达式" class="md-nav__link">
    和if一起使用的主要表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#if_1" title="if语句[ ] [[ ]]比较" class="md-nav__link">
    if语句[ ] [[ ]]比较
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ifthenelse" title="if/then/else构造" class="md-nav__link">
    if/then/else构造
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#then" title="then语句后面的命令" class="md-nav__link">
    then语句后面的命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" title="其他比较操作符" class="md-nav__link">
    其他比较操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fithen" title="嵌套的fi/then条件语句" class="md-nav__link">
    嵌套的fi/then条件语句
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" title="操作符" class="md-nav__link">
    操作符
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" title="数字常量" class="md-nav__link">
    数字常量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#readechoprintf" title="read内置命令是echo和printf命令的对应命令" class="md-nav__link">
    read内置命令是echo和printf命令的对应命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sedawkgrep" title="sed&amp;awk&amp;grep" class="md-nav__link">
    sed&amp;awk&amp;grep
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" title="文本间隔：" class="md-nav__link">
    文本间隔：
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" title="编号：" class="md-nav__link">
    编号：
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_23" title="文本转换和替代：" class="md-nav__link">
    文本转换和替代：
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_24" title="选择性地显示特定行：" class="md-nav__link">
    选择性地显示特定行：
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_25" title="选择性地删除特定行：" class="md-nav__link">
    选择性地删除特定行：
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_26" title="特殊应用：" class="md-nav__link">
    特殊应用：
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/Black-Gold/MyNotes/edit/master/docs/Shell.md" title="编辑此页" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="shell">shell笔记<a class="headerlink" href="#shell" title="Permanent link">&para;</a></h1>
<p>bash shell本身不支持正则表达式，使用正则的是shell命令和工具，如grep、sed等。bash shell可以使用正则表达式中的一些元字符实现通配(Globbing)功能。通配就是把一个包含通配符的非具体文件名扩展存储在计算机或网络上的一批具体文件名的过程。</p>
<ul>
<li>
<p>Reference List</p>
</li>
<li>
<p>Bash Guide for Beginners</p>
</li>
<li>Advanced Bash-Scripting Guide</li>
</ul>
<h2 id="shell_1">shell特殊变量基本解释<a class="headerlink" href="#shell_1" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><span class="nv">$*</span>     传递给程序的所有参数组成的字符串。
<span class="nv">$@</span>     所有的参数，每个都用双括号括起
<span class="nv">$#</span>     传递给程序的总的参数数目
<span class="nv">$*</span>     传递给程序的所有参数组成的字符串。
<span class="nv">$-</span>     在Shell启动或使用set命令时提供选项
<span class="nv">$?</span>     上一条命令执行后返回值

返回值参考：
<span class="m">0</span>      表示运行成功
<span class="m">2</span>      权限拒绝
<span class="m">1</span>~125  运行失败、脚本命令、系统命令错误或参数传递错误
<span class="m">126</span>    找到该命令但无法执行
<span class="m">127</span>    未找到要运行的命令
&gt;128   命令被系统强制结束
<span class="nv">$$</span>     当前shell的进程号
<span class="nv">$!</span>     上一个子进程的进程号
<span class="nv">$@</span>     所有的参数，每个都用双括号括起
<span class="nv">$n</span>     位置参数值，n表示位置
<span class="nv">$0</span>     当前shell名（当前执行进程的进程名）

数值比较：

-eq ：等于
-ne ：不等于
-gt ：大于
-lt  ：小于
-le  ：小于或等于
-ge ：大于或等于

逻辑测试：
<span class="o">&amp;&amp;</span> ：逻辑与
<span class="o">||</span> ：逻辑或
！ ：逻辑否
</pre></div>

<h2 id="shell_2">在shell中常用的特殊符号罗列如下：<a class="headerlink" href="#shell_2" title="Permanent link">&para;</a></h2>
<h3 id="command-separator">; 分号 (Command separator)<a class="headerlink" href="#command-separator" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在 shell 中，担任<span class="se">\&quot;</span>连续指令<span class="se">\&quot;</span>功能的符号就是<span class="se">\&quot;</span>分号<span class="se">\&quot;</span>。
譬如以下的例子：cd ~/backup <span class="p">;</span> mkdir startup <span class="p">;</span>cp ~/.* startup/.
</pre></div>

<h3 id="terminator">;; 连续分号 (Terminator)<a class="headerlink" href="#terminator" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>专用在 <span class="k">case</span> 的选项，担任 Terminator 的角色。
<span class="k">case</span> <span class="se">\&quot;</span><span class="nv">$fop</span><span class="se">\&quot;</span> inhelp<span class="o">)</span> <span class="nb">echo</span> <span class="se">\&quot;</span>Usage: Command -help -version filename<span class="se">\&quot;</span><span class="p">;;</span>version<span class="o">)</span> <span class="nb">echo</span> <span class="se">\&quot;</span>version <span class="m">0</span>.1<span class="se">\&quot;</span> <span class="p">;;</span><span class="k">esac</span>
</pre></div>

<h3 id="dot">. 逗号 (dot,就是“点”)<a class="headerlink" href="#dot" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。
<span class="nv">CDPATH</span><span class="o">=</span>.:~:/home:/home/web:/var:/usr/local
在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。
如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。除此之外，在 regularexpression 中，一个 dot 代表匹配一个字元。
</pre></div>

<h3 id="string-single-quote">'string' 单引号 (single quote)<a class="headerlink" href="#string-single-quote" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。
<span class="nv">heyyou</span><span class="o">=</span>homeecho <span class="s1">&#39;$heyyou&#39;</span> <span class="c1"># We get $heyyou</span>
</pre></div>

<h3 id="string-double-quote">\"string" 双引号 (double quote)<a class="headerlink" href="#string-double-quote" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。
<span class="nv">heyyou</span><span class="o">=</span>homeecho <span class="se">\&quot;</span><span class="nv">$heyyou</span><span class="se">\&quot;</span> <span class="c1"># We get home</span>
</pre></div>

<h3 id="96command-backticks">`command` 倒引号 (backticks)<a class="headerlink" href="#96command-backticks" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。
<span class="nv">fdv</span><span class="o">=</span><span class="sb">`</span>date +%F<span class="sb">`</span><span class="nb">echo</span> <span class="se">\&quot;</span>Today <span class="nv">$fdv</span><span class="se">\&quot;</span>
在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。
</pre></div>

<h3 id="comma">, 逗点 (comma，标点中的逗号)<a class="headerlink" href="#comma" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>这个符号常运用在运算当中当做<span class="se">\&quot;</span>区隔<span class="se">\&quot;</span>用途。如下例
<span class="c1">#!/bin/bashlet \&quot;t1 = ((a = 5 + 3, b = 7 - 1, c = 15 / 3))\&quot;echo \&quot;t1= $t1, a = $a, b = $b\&quot;</span>
</pre></div>

<h3 id="forward-slash">/ 斜线 (forward slash)<a class="headerlink" href="#forward-slash" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在路径表示时，代表目录。
<span class="nb">cd</span> /etc/rc.dcd ../..cd /
通常单一的 / 代表 root 根目录的意思；在四则运算中，代表除法的符号。
<span class="nb">let</span> <span class="se">\&quot;</span><span class="nv">num1</span> <span class="o">=</span> <span class="o">((</span><span class="nv">a</span> <span class="o">=</span> <span class="m">10</span> / <span class="m">2</span>, <span class="nv">b</span> <span class="o">=</span> <span class="m">25</span> / <span class="m">5</span><span class="o">))</span><span class="se">\&quot;</span>
</pre></div>

<h3 id="9232">\ 倒斜线<a class="headerlink" href="#9232" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在交互模式下的escape 字元，有几个作用；放在指令前，有取消 aliases的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令的最末端，表示指令连接下一行。
<span class="c1"># type rmrm is aliased to `rm -i&#39;# \\rm ./*.log</span>
上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。
<span class="c1"># bkdir=/home# echo \&quot;Backup dir, \\$bkdir = $bkdir\&quot;Backup dir,$bkdir = /home</span>
上例 <span class="nb">echo</span> 内的 <span class="se">\\</span><span class="nv">$bkdir</span>，escape 将 $ 变数的功能取消了，因此，会输出 <span class="nv">$bkdir</span>，而第二个 <span class="nv">$bkdir则会输出变数的内容</span> /home。
</pre></div>

<h3 id="pipeline">| 管道 (pipeline)<a class="headerlink" href="#pipeline" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。
who <span class="p">|</span> wc -l
善用这个观念，对精简 script 有相当的帮助。
</pre></div>

<h3 id="negate-or-reverse">! 惊叹号(negate or reverse)<a class="headerlink" href="#negate-or-reverse" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>通常它代表反逻辑的作用，譬如条件侦测中，用 !<span class="o">=</span> 来代表<span class="se">\&quot;</span>不等于<span class="se">\&quot;</span>
<span class="k">if</span> <span class="o">[</span> <span class="se">\&quot;</span><span class="nv">$?</span><span class="se">\&quot;</span> !<span class="o">=</span> <span class="m">0</span> <span class="o">]</span>thenecho <span class="se">\&quot;</span>Executes error<span class="se">\&quot;</span><span class="nb">exit</span> 1fi
在规则表达式中她担任 <span class="se">\&quot;</span>反逻辑<span class="se">\&quot;</span> 的角色
ls a<span class="o">[</span>!0-9<span class="o">]</span>
上例，代表显示除了a0, a1 .... a9 这几个文件的其他文件。
</pre></div>

<h3 id="_1">: 冒号<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在 bash 中，这是一个内建指令：<span class="se">\&quot;</span>什么事都不干<span class="se">\&quot;</span>，但返回状态值 <span class="m">0</span>。
:
<span class="nb">echo</span> <span class="nv">$?</span> <span class="c1"># 回应为 0</span>
: &gt; f.<span class="nv">$$</span>
上面这一行，相当于 cat /dev/null &gt;f.<span class="nv">$$</span>。不仅写法简短了，而且执行效率也好上许多。
有时，也会出现以下这类的用法
: <span class="si">${</span><span class="nv">HOSTNAME</span><span class="p">?</span><span class="si">}</span> <span class="si">${</span><span class="nv">USER</span><span class="p">?</span><span class="si">}</span> <span class="si">${</span><span class="nv">MAIL</span><span class="p">?</span><span class="si">}</span>
这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 <span class="nb">test</span> 或 if这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。
</pre></div>

<h3 id="wild-card">? 问号 (wild card)<a class="headerlink" href="#wild-card" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在文件名扩展<span class="o">(</span>Filename expansion<span class="o">)</span>上扮演的角色是匹配一个任意的字元，但不包含 null 字元。
<span class="c1"># ls a?a1</span>
善用它的特点，可以做比较精确的档名匹配。
</pre></div>

<h3 id="wild-card_1">* 星号 (wild card)<a class="headerlink" href="#wild-card_1" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>相当常用的符号。在文件名扩展<span class="o">(</span>Filename expansion<span class="o">)</span>上，她用来代表任何字元，包含 null 字元。
<span class="c1"># ls a*a a1 access_log</span>
在运算时，它则代表 <span class="se">\&quot;</span>乘法<span class="se">\&quot;</span>。
<span class="nb">let</span> <span class="se">\&quot;</span><span class="nv">fmult</span><span class="o">=</span><span class="m">2</span>*3<span class="se">\&quot;</span>
除了内建指令 let，还有一个关于运算的指令expr，星号在这里也担任<span class="se">\&quot;</span>乘法<span class="se">\&quot;</span>的角色。不过在使用上得小心，他的前面必须加上escape 字元。
</pre></div>

<h3 id="_2">** 次方运算<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>两个星号在运算时代表 <span class="se">\&quot;</span>次方<span class="se">\&quot;</span> 的意思。
<span class="nb">let</span> <span class="se">\&quot;</span><span class="nv">sus</span><span class="o">=</span><span class="m">2</span>**3<span class="se">\&quot;</span><span class="nb">echo</span> <span class="se">\&quot;</span><span class="nv">sus</span> <span class="o">=</span> <span class="nv">$sus</span><span class="se">\&quot;</span> <span class="c1"># sus = 8</span>
</pre></div>

<h3 id="dollardollar-sign">$ dollar符号(dollar sign)<a class="headerlink" href="#dollardollar-sign" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>变量替换<span class="o">(</span>Variable Substitution<span class="o">)</span>的代表符号。
<span class="nv">vrs</span><span class="o">=</span>123echo <span class="se">\&quot;</span><span class="nv">vrs</span> <span class="o">=</span> <span class="nv">$vrs</span><span class="se">\&quot;</span> <span class="c1"># vrs = 123</span>
另外，在 Regular Expressions 里被定义为 <span class="se">\&quot;</span>行<span class="se">\&quot;</span> 的最末端 <span class="o">(</span>end-of-line<span class="o">)</span>。这个常用在grep、sed、awk 以及 vim<span class="o">(</span>vi<span class="o">)</span> 当中。
</pre></div>

<h3 id="_3">${} 变量的正规表达式<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>bash 对 <span class="si">${}</span> 定义了不少用法。以下是取自线上说明的表列
<span class="si">${</span><span class="nv">parameter</span><span class="k">:-</span><span class="nv">word</span><span class="si">}</span>   <span class="si">${</span><span class="nv">parameter</span><span class="p">:=word</span><span class="si">}</span>   <span class="si">${</span><span class="nv">parameter</span><span class="p">:?word</span><span class="si">}</span>  <span class="si">${</span><span class="nv">parameter</span><span class="p">:+word</span><span class="si">}</span>   <span class="si">${</span><span class="nv">parameterffset</span><span class="si">}</span>   <span class="o">{</span>parameterffset:length<span class="o">}</span>   <span class="si">${</span><span class="p">!prefix*</span><span class="si">}</span>   <span class="si">${#</span><span class="nv">parameter</span><span class="si">}</span>   <span class="o">{</span>parameter#word<span class="o">}</span>   <span class="si">${</span><span class="nv">parameter</span><span class="p">##word</span><span class="si">}</span>   <span class="si">${</span><span class="nv">parameter</span><span class="p">%word</span><span class="si">}</span>   <span class="o">{</span>parameter%%word<span class="o">}</span>   <span class="si">${</span><span class="nv">parameter</span><span class="p">/pattern/string</span><span class="si">}</span>   <span class="o">{</span>parameter//pattern/string<span class="o">}</span>
</pre></div>

<h3 id="_4">$*符号<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="nv">$*</span> 引用script的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下：
<span class="nv">$0</span>, <span class="nv">$1</span>, <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$5</span>, <span class="nv">$6</span>, <span class="nv">$7</span>, <span class="nv">$8</span>, <span class="nv">$9</span>, <span class="si">${</span><span class="nv">10</span><span class="si">}</span>, <span class="si">${</span><span class="nv">11</span><span class="si">}</span>.....
个位数的，可直接使用数字，但两位数以上，则必须使用 <span class="o">{}</span> 符号来括住。
<span class="nv">$*</span> 则是代表所有引用变量的符号。使用时，得视情况加上双引号。
<span class="nb">echo</span> <span class="se">\&quot;</span><span class="nv">$*</span><span class="se">\&quot;</span>
还有一个与 <span class="nv">$*</span> 具有相同作用的符号，但效用与处理方式略为不同的符号。
</pre></div>

<h3 id="_5">$@<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="nv">$@</span> 与 <span class="nv">$*</span> 具有相同作用的符号，不过她们两者有一个不同点。
符号 <span class="nv">$*</span> 将所有的引用变量视为一个整体。但符号 <span class="nv">$@</span> 则仍旧保留每个引用变量的区段观念。
</pre></div>

<p>$#</p>
<div class="codehilite"><pre><span></span>这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。
<span class="nb">echo</span> <span class="se">\&quot;</span><span class="nv">$#</span><span class="se">\&quot;</span>
</pre></div>

<h3 id="status-variable">$? 状态值 (status variable)<a class="headerlink" href="#status-variable" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>一般来说，UNIX<span class="o">(</span>linux<span class="o">)</span> 系统的进程以执行系统调用exit<span class="o">()</span>来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。
一般指令程序倘若执行成功，其回传值为 <span class="m">0</span>；失败为 <span class="m">1</span>。
tar cvfz dfbackup.tar.gz /home/user &gt; /dev/nullecho<span class="se">\&quot;</span><span class="nv">$?</span><span class="se">\&quot;</span><span class="nv">$$</span>
由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script会需要产生临时文件，用来存放必要的资料。而此script亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。符号<span class="nv">$$</span>或许可以符合这种需求。它代表当前shell 的 PID。
<span class="nb">echo</span> <span class="se">\&quot;</span><span class="nv">$HOSTNAME</span>, <span class="nv">$USER</span>, <span class="nv">$MAIL</span><span class="se">\&quot;</span> &gt; ftmp.<span class="nv">$$</span>
使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。
ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果script 执行完毕后仍不加以清除，会产生其他问题。
</pre></div>

<h3 id="_6">$$<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>进程ID变量，保存了脚本运行时的ID
</pre></div>

<h3 id="command-group">(   ) 指令群组 (command group)<a class="headerlink" href="#command-group" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子：<span class="o">(</span><span class="nb">cd</span> ~ <span class="p">;</span> <span class="nv">vcgh</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span> <span class="p">;</span><span class="nb">echo</span> <span class="nv">$vcgh</span><span class="o">)</span>，指令群组有一个特性，shell会以产生 subshell来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子
<span class="c1"># cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e \&quot;\\n $a \\n\&quot;)echo $a#./ftmp-01incgfsh</span>
除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape字元才能使用的场合，如运算式。
</pre></div>

<h3 id="_7">(( ))<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>这组符号的作用与 <span class="nb">let</span> 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let指令要好许多。
<span class="c1">#!/bin/bash(( a = 10 ))echo -e \&quot;inital value, a = $a\\n\&quot;(( a++))echo \&quot;after a++, a = $a\&quot;</span>
</pre></div>

<h3 id="block-of-code">{ } 大括号 (Block of code)<a class="headerlink" href="#block-of-code" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>有时候脚本当中会出现，大括号中会夹着一段或几段以<span class="se">\&quot;</span>分号<span class="se">\&quot;</span>做结尾的指令或变数设定。
<span class="c1"># cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e \&quot;\\n $a \\n\&quot;}echo $a#./ftmp-02inbcinbc</span>
这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的 shell 执行，不会产生 subshell。
大括号也被运用在 <span class="se">\&quot;</span>函数<span class="se">\&quot;</span> 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。
此外，大括号还有另一种用法，如下
<span class="o">{</span>xx,yy,zz,...<span class="o">}</span>
这种大括号的组合，常用在字串的组合上，来看个例子
mkdir <span class="o">{</span>userA,userB,userC<span class="o">}</span>-<span class="o">{</span>home,bin,data<span class="o">}</span>
我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data，这几个目录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子
chown root /usr/<span class="o">{</span>ucb/<span class="o">{</span>ex,edit<span class="o">}</span>,lib/<span class="o">{</span>ex?.?*,how_ex<span class="o">}}</span>
如果不是因为支援这种用法，我们得写几行重复几次呀！
</pre></div>

<h3 id="_8">[ ] 中括号<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>常出现在流程控制中，扮演括住判断式的作用。if <span class="o">[</span> <span class="se">\&quot;</span><span class="nv">$?</span><span class="se">\&quot;</span> !<span class="o">=</span> <span class="m">0</span> <span class="o">]</span>thenecho <span class="se">\&quot;</span>Executes error<span class="se">\&quot;</span>exit1fi
这个符号在正则表达式中担任类似 <span class="se">\&quot;</span>范围<span class="se">\&quot;</span> 或 <span class="se">\&quot;</span>集合<span class="se">\&quot;</span> 的角色
rm -r <span class="m">200</span><span class="o">[</span><span class="m">1234</span><span class="o">]</span>
上例，代表删除 <span class="m">2001</span>, <span class="m">2002</span>, <span class="m">2003</span>, <span class="m">2004</span> 等目录的意思。
</pre></div>

<p>{} \;</p>
<div class="codehilite"><pre><span></span>路径名，基本用于find命令内，不是shell內建命令
分号<span class="p">;</span> 结束find命令中-exec选项的命令序列，应该转义以免被shell误解释
</pre></div>

<h3 id="_9">[[ ]]<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>这组符号与先前的 <span class="o">[]</span> 符号，基本上作用相同，但她允许在其中直接使用 <span class="o">||</span> 与<span class="o">&amp;&amp;</span> 逻辑等符号。
<span class="c1">#!/bin/bashread akif [[ $ak &gt; 5 || $ak&lt; 9 ]]thenecho $akfi</span>
</pre></div>

<h3 id="-or">|| 逻辑符号----代表 or 逻辑的符号。<a class="headerlink" href="#-or" title="Permanent link">&para;</a></h3>
<h3 id="-and">&amp;&amp; 逻辑符号----代表 and 逻辑的符号。<a class="headerlink" href="#-and" title="Permanent link">&para;</a></h3>
<h3 id="_10">&amp; 后台工作<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>单一个<span class="p">&amp;</span> 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。
tar cvfz data.tar.gz data &gt; /dev/null<span class="p">&amp;</span>
</pre></div>

<h3 id="9292">\&lt;...\&gt; 单字边界<a class="headerlink" href="#9292" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>这组符号在规则表达式中，被定义为<span class="se">\&quot;</span>边界<span class="se">\&quot;</span>的意思。譬如，当我们想找寻 the 这个单字时，如果我们用
grep the FileA
你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there的一部份。如果我们要必免这种情况，就得加上 <span class="se">\&quot;</span>边界<span class="se">\&quot;</span> 的符号
grep <span class="s1">&#39;\\&#39;</span> FileA
</pre></div>

<h3 id="plus">+ 加号 (plus)<a class="headerlink" href="#plus" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在运算式中，她用来表示 <span class="se">\&quot;</span>加法<span class="se">\&quot;</span>。
expr <span class="m">1</span> + <span class="m">2</span> + <span class="m">3</span>
此外在规则表达式中，用来表示<span class="se">\&quot;</span>很多个<span class="se">\&quot;</span>的前面字元的意思。
<span class="c1"># grep &#39;10\\+9&#39; fileB109100910000910000931010009#这个符号在使用时，前面必须加上escape 字元。</span>
</pre></div>

<h3 id="-dash">- 减号 (dash)<a class="headerlink" href="#-dash" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在运算式中，她用来表示 <span class="se">\&quot;</span>减法<span class="se">\&quot;</span>。
expr <span class="m">10</span> - <span class="m">2</span>
此外也是系统指令的选项符号。
ls -expr <span class="m">10</span> - <span class="m">2</span>
在 GNU 指令中，如果单独使用 - 符号，不加任何该加的文件名称时，代表<span class="se">\&quot;</span>标准输入<span class="se">\&quot;</span>的意思。这是 GNU指令的共通选项。譬如下例
tar xpvf -
这里的 - 符号，既代表从标准输入读取资料。
不过，在 <span class="nb">cd</span> 指令中则比较特别
<span class="nb">cd</span> -
这代表变更工作目录到<span class="se">\&quot;</span>上一次<span class="se">\&quot;</span>工作目录。
</pre></div>

<h3 id="modulo">% 除法 (Modulo)<a class="headerlink" href="#modulo" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>在运算式中，用来表示 <span class="se">\&quot;</span>除法<span class="se">\&quot;</span>。
expr <span class="m">10</span> % <span class="m">2</span>
此外，也被运用在关于变量的规则表达式当中的下列
<span class="si">${</span><span class="nv">parameter</span><span class="p">%word</span><span class="si">}${</span><span class="nv">parameter</span><span class="p">%%word</span><span class="si">}</span>
一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。
</pre></div>

<h3 id="equals">= 等号 (Equals)<a class="headerlink" href="#equals" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>常在设定变数时看到的符号。
<span class="nv">vara</span><span class="o">=</span>123echo <span class="se">\&quot;</span> <span class="nv">vara</span> <span class="o">=</span> <span class="nv">$vara</span><span class="se">\&quot;</span>
或者像是 PATH 的设定，甚至应用在运算或判断式等此类用途上。
</pre></div>

<h3 id="equals_1">== 等号 (Equals)<a class="headerlink" href="#equals_1" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>常在条件判断式中看到，代表 <span class="se">\&quot;</span>等于<span class="se">\&quot;</span> 的意思。
<span class="k">if</span> <span class="o">[</span> <span class="nv">$vara</span> <span class="o">==</span> <span class="nv">$varb</span> <span class="o">]</span>
...下略
</pre></div>

<h3 id="_11">!= 不等于<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>常在条件判断式中看到，代表 <span class="se">\&quot;</span>不等于<span class="se">\&quot;</span> 的意思。
<span class="k">if</span> <span class="o">[</span> <span class="nv">$vara</span> !<span class="o">=</span> <span class="nv">$varb</span> <span class="o">]</span>
...下略
</pre></div>

<p>^
在规则表达式中，代表行的 \"开头\" 位置，在[]中也与\"!\"(叹号)一样表示“非”</p>
<p>输出/输入重定向 &gt; &gt;&gt;   &lt;   &lt;&lt;   :&gt;   &amp;&gt;   2&amp;&gt;   2&lt;&gt;&gt;&amp;   &gt;&amp;2</p>
<div class="codehilite"><pre><span></span>文件描述符<span class="o">(</span>File Descriptor<span class="o">)</span>，用一个数字（通常为0-9）来表示一个文件。
常用的文件描述符如下：
文件描述符     名称     常用缩写    默认值
<span class="m">0</span>        标准输入       stdin      键盘
<span class="m">1</span>        标准输出       stdout     屏幕
<span class="m">2</span>        标准错误输出    stderr     屏幕
我们在简单地用&lt;或&gt;时，相当于使用 <span class="m">0</span>&lt; 或 <span class="m">1</span>&gt;（下面会详细介绍）。
* cmd &gt; file
把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的noclobber选项可以防止复盖原有文件。
* cmd &gt;&gt; file
把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件後面。
* cmd &lt; file
使cmd命令从file读入
* cmd <span class="s">&lt;&lt; text</span>
<span class="s">从命令行读取输入，直到一个与text</span>相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。如果使用&lt;&lt;- ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考後面的例子。
* cmd <span class="o">&lt;&lt;&lt;</span> word
把word（而不是文件word）和後面的换行作为输入提供给cmd。
* cmd &lt;&gt; file
以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。
* cmd &gt;<span class="p">|</span> file
功能同&gt;，但即便在设置了noclobber时也会复盖file文件，注意用的是<span class="p">|</span>而非一些书中说的!，目前仅在csh中仍沿用&gt;!实现这一功能。
: &gt; filename    把文件<span class="se">\&quot;</span>filename<span class="se">\&quot;</span>截断为0长度.# 如果文件不存在, 那么就创建一个0长度的文件<span class="o">(</span>与<span class="s1">&#39;touch&#39;</span>的效果相同<span class="o">)</span>.
cmd &gt;<span class="p">&amp;</span>n 把输出送到文件描述符n
cmd m&gt;<span class="p">&amp;</span>n 把输出 到文件符m的信息重定向到文件描述符n
cmd &gt;<span class="p">&amp;</span>- 关闭标准输出
cmd &lt;<span class="p">&amp;</span>n 输入来自文件描述符n
cmd m&lt;<span class="p">&amp;</span>n m来自文件描述各个n
cmd &lt;<span class="p">&amp;</span>- 关闭标准输入
cmd &lt;<span class="p">&amp;</span>n- 移动输入文件描述符n而非复制它。（需要解释）
cmd &gt;<span class="p">&amp;</span>n- 移动输出文件描述符 n而非复制它。（需要解释）
注意： &gt;<span class="p">&amp;</span>实际上复制了文件描述符，这使得cmd &gt; file <span class="m">2</span>&gt;<span class="p">&amp;</span>1与cmd <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> &gt;file的效果不一样。
<span class="p">&amp;</span>&gt; file和 &gt; file <span class="m">2</span>&gt;<span class="p">&amp;</span>1相同
</pre></div>

<h3 id="-">-<a class="headerlink" href="#-" title="Permanent link">&para;</a></h3>
<p>用于stdin或stdout重定向的源或目的[dash]</p>
<div class="codehilite"><pre><span></span><span class="nb">echo</span> <span class="s2">&quot;whatever&quot;</span> <span class="p">|</span> cat - <span class="c1">#输出 whatever</span>
</pre></div>

<p>使用- 的tar命令的真实例子</p>
<div class="codehilite"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#  备份当前目录下所有前24小时被修改的文件为一个归档压缩包（归档并且压缩）</span>
 <span class="nv">BACKUPFILE</span><span class="o">=</span>backup-<span class="k">$(</span>date +%m-%d-%Y<span class="k">)</span>
  <span class="c1">#                 在备份文件中嵌入日期.</span>
  <span class="c1">#                 多谢Joshua Tschida的这个主意.</span>
  <span class="nv">archive</span><span class="o">=</span><span class="si">${</span><span class="nv">1</span><span class="k">:-</span><span class="nv">$BACKUPFILE</span><span class="si">}</span>
  <span class="c1">#  如果没有在命令行上指定备份的归档文件名,</span>
  <span class="c1">#+ 会以&quot;backup-MM-DD-YYYY.tar.gz.&quot;作为默认的文件名</span>

  tar cvf - <span class="sb">`</span>find . -mtime -1 -type f -print<span class="sb">`</span> &gt; <span class="nv">$archive</span>.tar
  gzip <span class="nv">$archive</span>.tar
  <span class="nb">echo</span> <span class="s2">&quot;Directory </span><span class="nv">$PWD</span><span class="s2"> backed up in archive file \&quot;</span><span class="nv">$archive</span><span class="s2">.tar.gz\&quot;.&quot;</span>


  <span class="c1">#  Stephane Chazelas指出：如果有许多文件被找到</span>
  <span class="c1">#+ 或任何一个文件名中包含有空白字符</span>
  <span class="c1">#+ 上面的代码将会失败.</span>

  <span class="c1"># 他建议用下面的代码:</span>
  <span class="c1"># -------------------------------------------------------------------</span>
  <span class="c1">#   find . -mtime -1 -type f -print0 | xargs -0 tar rvf &quot;$archive.tar&quot;</span>
  <span class="c1">#      using the GNU version of &quot;find&quot;.</span>

  <span class="c1">#   find . -mtime -1 -type f -exec tar rvf &quot;$archive.tar&quot; &#39;{}&#39; \;</span>

  <span class="nb">exit</span> <span class="m">0</span>
</pre></div>

<p>先前的工作目录. 命令cd - 可以回到原来的工作目录.它使用了$OLDPWD 环境变量.
不要弄混了这儿使用的"-"和上面刚讨论的"-"重定向操作符.对于"-"字符的解释应依赖于它出现的环境.</p>
<p>负号或减号. 减号用于算术操作</p>
<h3 id="_12">~<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<p>主目录或称为家目录[波浪号]. 它与内部变量 $HOME 是一致的. ~bozo是bozo'的主目录,而ls ~bozo 会列出此目录的内容. ~/ 是当前用户的主目录,并且ls ~/ 会列出此目录的内容.</p>
<h3 id="_13">~+<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<p>当前工作目录. 它与外部变量$PWD是一致的</p>
<h3 id="-_1">~-<a class="headerlink" href="#-_1" title="Permanent link">&para;</a></h3>
<p>先前的工作目录. 它与外部变量$OLDPWD是一致的</p>
<h3 id="_14">控制字符<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>更改终端行为或文本显示. 控制字符都是以CONTROL + key的组合键.

在脚本文件中控制字符是不起作用的
Ctl-B

退格 <span class="o">(</span>非破坏性的<span class="o">)</span>.

Ctl-C

中断. 终结一个前台作业.


Ctl-D

从一个shell中退出 <span class="o">(</span>类似于exit<span class="o">)</span>.

<span class="s2">&quot;EOF&quot;</span> <span class="o">(</span>文件结尾：end of file<span class="o">)</span>.它也用于表示标准输入（stdin）的结束.

在控制台或xterm 窗口输入文本时, Ctl-D删除在光标下的字符.如果没有字符存在，Ctl-D 则会登录出该会话. 在一个xterm窗口中，则会产生关闭此窗口的效果。

Ctl-G

<span class="s2">&quot;哔&quot;</span> <span class="o">(</span>beep<span class="o">)</span>.在一些老式的打字机终端上，它会响一下铃.

Ctl-H

<span class="s2">&quot;杀掉&quot;</span> <span class="o">(</span>破坏性的退格<span class="o">)</span>. 删除光标前的一个字符＝＝＝.

   <span class="m">1</span> <span class="c1">#!/bin/bash</span>
   <span class="m">2</span> <span class="c1"># 在一个字符串里嵌入 Ctl-H.</span>
   <span class="m">4</span> <span class="nv">a</span><span class="o">=</span><span class="s2">&quot;^H^H&quot;</span>                  <span class="c1"># 两个 Ctl-H (退格).</span>
   <span class="m">5</span> <span class="nb">echo</span> <span class="s2">&quot;abcdef&quot;</span>             <span class="c1"># abcdef</span>
   <span class="m">6</span> <span class="nb">echo</span> -n <span class="s2">&quot;abcdef</span><span class="nv">$a</span><span class="s2"> &quot;</span>       <span class="c1"># abcd f</span>
   <span class="m">7</span> <span class="c1">#以一个空格结尾  ^              ^ 退二格.</span>
   <span class="m">8</span> <span class="nb">echo</span> -n <span class="s2">&quot;abcdef</span><span class="nv">$a</span><span class="s2">&quot;</span>        <span class="c1"># abcdef</span>
   <span class="m">9</span> <span class="c1">#  现在没有尾部的空格            不退格了 (为什么?).</span>
  <span class="m">10</span>                           <span class="c1"># 结果和预料的不一样.</span>
  <span class="m">11</span> echo<span class="p">;</span> <span class="nb">echo</span>

Ctl-I

水平制表符.

Ctl-J

新行<span class="o">(</span>换一行并到行首<span class="o">)</span>.

Ctl-K

垂直制表符.

在控制台或xterm 窗口输入文本时, Ctl-K 会删除从光标所在处到行尾的所有字符。

Ctl-L

清屏 <span class="o">(</span>重绘屏幕，清除前面的打印信息<span class="o">)</span>.这与clear命令作用相同.

Ctl-M

回车.

   <span class="m">1</span> <span class="c1">#!/bin/bash</span>
   <span class="m">2</span> <span class="c1"># 多谢Lee Maschmeyer的例子</span>
   <span class="m">4</span> <span class="nb">read</span> -n <span class="m">1</span> -s -p <span class="s1">$&#39;Control-M leaves cursor at beginning of this line. Press Enter. \x0d&#39;</span>
   <span class="m">5</span>                                   <span class="c1"># 是的, &#39;0d&#39;是Control-M的十六进制值.</span>
   <span class="m">6</span> <span class="nb">echo</span> &gt;<span class="p">&amp;</span><span class="m">2</span>   <span class="c1">#  &#39;-s&#39;使所有被键入的字符都不回显,</span>
   <span class="m">7</span>            <span class="c1">#+ 所以需要明确地键入新行.</span>
   <span class="m">9</span> <span class="nb">read</span> -n <span class="m">1</span> -s -p <span class="s1">$&#39;Control-J leaves cursor on next line. \x0a&#39;</span>
  <span class="m">10</span> <span class="nb">echo</span> &gt;<span class="p">&amp;</span><span class="m">2</span>   <span class="c1">#  Control-J 是换行.</span>
  <span class="m">12</span> <span class="c1">###</span>
  <span class="m">14</span> <span class="nb">read</span> -n <span class="m">1</span> -s -p <span class="s1">$&#39;And Control-K\x0bgoes straight down.&#39;</span>
  <span class="m">15</span> <span class="nb">echo</span> &gt;<span class="p">&amp;</span><span class="m">2</span>   <span class="c1">#  Control-K 是垂直制表符.</span>
  <span class="m">17</span> <span class="c1"># 展示垂直制表符作用的更好的例子是:</span>
  <span class="m">19</span> <span class="nv">var</span><span class="o">=</span><span class="s1">$&#39;\x0aThis is the bottom line\x0bThis is the top line\x0a&#39;</span>
  <span class="m">20</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span>
  <span class="m">21</span> <span class="c1">#  这和上面的例子一样工作.但是:</span>
  <span class="m">22</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span> <span class="p">|</span> col
  <span class="m">23</span> <span class="c1">#  这使行的右端比左端更高.</span>
  <span class="m">24</span> <span class="c1">#  这也解释了为什么我们以一个换行符开始和结束 --</span>
  <span class="m">25</span> <span class="c1">#+ 是为了避免屏幕显示混乱.</span>
  <span class="m">27</span> <span class="c1"># 这是Lee Maschmeyer的解释:</span>
  <span class="m">28</span> <span class="c1"># --------------------------</span>
  <span class="m">29</span> <span class="c1">#  在第一个垂直制表符例子中 . . . 垂直制表符使还未打印回车就直接垂直打印下来。</span>
  <span class="m">30</span> <span class="c1">#</span>
  <span class="m">31</span> <span class="c1">#  这只在不能“倒后”的设备里才成立,比如在Linux控制台,</span>
  <span class="m">32</span> <span class="c1">#</span>
  <span class="m">33</span> <span class="c1">#  垂直制表符真正的意图是能垂直地往上移，而不是往下移.</span>
  <span class="m">34</span> <span class="c1">#  可以在打印机里用于打印上标.</span>
  <span class="m">35</span> <span class="c1">#  这个要点的作用被用于仿效垂直制表符正确的功能.</span>
  <span class="m">37</span> <span class="nb">exit</span> <span class="m">0</span>

Ctl-Q

解冻 <span class="o">(</span>XON<span class="o">)</span>.

它解冻终端的标准输入.

Ctl-S

挂起输入 <span class="o">(</span>XOFF<span class="o">)</span>.

它冻结终端的标准输入. <span class="o">(</span>用 Ctl-Q 可恢复输入.<span class="o">)</span>

Ctl-U

删除从光标到行首的一行输入.在某些设置里，Ctl-U 删除整行的输入，而不管光标的位置.

Ctl-V

当输入一个文本, Ctl-V允许插入控制字符。例如，下面两个命令是相等的:
   <span class="m">1</span> <span class="nb">echo</span> -e <span class="s1">&#39;\x0a&#39;</span>
   <span class="m">2</span> <span class="nb">echo</span> &lt;Ctl-V&gt;&lt;Ctl-J&gt;

Ctl-V 主要用于文本编辑.

Ctl-W

当在控制台或一个xterm窗口敲入文本时, Ctl-W 会删除从在光标处往后的第一个空白符之间的内容.在某些设置里, Ctl-W 删除光标往后到第一个非文字和数字之间的字符.

Ctl-Z

暂停一个前台作业.
</pre></div>

<h3 id="shell_3">shell多行注释实现方式<a class="headerlink" href="#shell_3" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>方法一：
: <span class="s">&lt;&lt; 字符</span>
<span class="s">语句</span>
<span class="s">字符</span>

方法二：
: <span class="s1">&#39;</span>
<span class="s1">语句</span>
<span class="s1">&#39;</span>
</pre></div>

<h3 id="_15">变量替换<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="nv">Var1</span><span class="o">=</span><span class="m">12</span>
<span class="nv">Var2</span><span class="o">=</span><span class="nv">$Var1</span> <span class="c1">#等号两边不能有空白符</span>

<span class="nb">echo</span> <span class="nv">$Var1</span>
<span class="nb">echo</span> <span class="nv">$Var2</span>
<span class="nb">echo</span> <span class="si">${</span><span class="nv">Var2</span><span class="si">}</span> <span class="c1">#与上句表示的一样，$Var2是其简写形式</span>

<span class="nv">Var2</span><span class="o">=</span><span class="s2">&quot;a b  c&quot;</span>
<span class="nb">echo</span> <span class="nv">$Var2</span> <span class="c1">#输出为a b c</span>
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$Var2</span><span class="s2">&quot;</span> <span class="c1">#输出为a b  c</span>
<span class="c1"># 两者输出不同，把变量用双引号引起来会保留空白字符</span>

<span class="nb">echo</span> <span class="s1">&#39;$Var2&#39;</span> <span class="c1">#把变量用单引号引起来只表示普通的字符</span>

<span class="c1">#设置Var2为null value</span>
<span class="nv">Var2</span><span class="o">=</span>
<span class="nb">echo</span> <span class="s2">&quot;\$Var2(null value)=</span><span class="nv">$Var2</span><span class="s2">&quot;</span>
<span class="c1">#注意：具有null值的变量不等同于废弃(unset)此变量，虽然结果都相同</span>

<span class="nv">Nub1</span><span class="o">=</span><span class="s2">&quot;1 2 3&quot;</span> <span class="c1">#给变量赋值有空白时，引号时必须的</span>
<span class="nb">echo</span> <span class="nv">$Nub1</span>

<span class="c1">#未初始化的变量具有null值</span>
<span class="nv">Nub2</span><span class="o">=</span>

<span class="c1">#一个未初始化的变量有一个”null”值――表示从没有被赋值过（注意null值不等于零）。在一个变量从未赋值之前就使用它通常会引起问题。然而，仍然有可能在执行算术计算时使用一个未初始化的变量。</span>

<span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$Nub2</span><span class="s2">&quot;</span>
<span class="nb">let</span> <span class="s2">&quot;Nub2 += 2&quot;</span>
<span class="nb">echo</span> <span class="nv">$Nub2</span>

<span class="c1">##变量赋值</span>
<span class="c1">#赋值操作符(它的两边不能有空白符)</span>
<span class="c1">#不要搞混=和-eq，-eq是比赋值操作更高级的测试</span>
<span class="c1">#等号=在不同的环境不同，可能时赋值操作符也可能时测试操作符</span>

<span class="c1">#当变量被赋值而不是引用时，称之为裸变量</span>
<span class="c1">#赋值</span>
<span class="nv">a</span><span class="o">=</span><span class="m">3</span>
<span class="nb">echo</span> <span class="s2">&quot;这个变量\&quot;a\&quot;是</span><span class="nv">$a</span><span class="s2">&quot;</span>

<span class="c1">#用let命令赋值</span>
<span class="nb">let</span> <span class="nv">a</span><span class="o">=</span><span class="m">12</span>+42
<span class="nb">echo</span> <span class="s2">&quot;let赋值的变量\&quot;a\&quot;是</span><span class="nv">$a</span><span class="s2">&quot;</span>

<span class="c1">#在一个循环中赋值(其实是一种伪赋值)</span>
<span class="k">for</span> a in <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span>
<span class="k">do</span>
    <span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span>
<span class="k">done</span>

: &lt;&lt;!
<span class="c1">#使用read命令(也是一种赋值)</span>
<span class="nb">echo</span> -n <span class="s2">&quot;输入：\&quot;a\&quot;&quot;</span>
<span class="nb">read</span> a
<span class="nb">echo</span> <span class="s2">&quot;read赋值后\&quot;a\&quot;是</span><span class="nv">$a</span><span class="s2">&quot;</span>
!

<span class="c1"># 简述简单而又奇特的变量赋值</span>
<span class="nv">a</span><span class="o">=</span><span class="m">1</span>
<span class="nb">echo</span> <span class="nv">$a</span>
<span class="nv">b</span><span class="o">=</span><span class="nv">$a</span>
<span class="nb">echo</span> <span class="nv">$b</span>

<span class="c1">#下面讲奇怪的赋值(命令替换)</span>
<span class="nv">a</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> hello!<span class="sb">`</span> <span class="c1">#把echo命令的结果赋值给变量a</span>
<span class="nb">echo</span> <span class="nv">$a</span>
<span class="c1">#若只在一个命令替换结构中包含一个感叹号!，将不会工作，因为感叹号触发了bash历史命令机制。不过在脚本中，历史命令机制是被禁止的。</span>
<span class="nv">a</span><span class="o">=</span><span class="sb">`</span>ls -l<span class="sb">`</span> <span class="c1">#把ls -a的结果赋值给变量a</span>
<span class="nb">echo</span> <span class="nv">$a</span> <span class="c1">#没有引号则会删除多余的tab键和空白符</span>
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> <span class="c1">#加引号可以保留空白符</span>
<span class="nv">R</span><span class="o">=</span><span class="k">$(</span>cat /etc/lsb-release<span class="k">)</span>
<span class="nv">arch</span><span class="o">=</span><span class="k">$(</span>uname -m<span class="k">)</span>

<span class="nb">echo</span> <span class="nv">$R</span>
<span class="nb">echo</span> <span class="nv">$arch</span>
</pre></div>

<p>echo命令使用的转义序列</p>
<table>
<thead>
<tr>
<th align="center">序列</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">\a</td>
<td align="center">Alert (bell)</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">Backspace</td>
</tr>
<tr>
<td align="center">\c</td>
<td align="center">Suppress trailing newline</td>
</tr>
<tr>
<td align="center">\e</td>
<td align="center">Escape</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">Form feed</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">Newline</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">Carriage return</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">Horizontal tab</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="center">Vertical tab</td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">Backslash</td>
</tr>
<tr>
<td align="center">\0NNN</td>
<td align="center">The eight-bit character whose value is the octal value NNN (zero to three octal digits)</td>
</tr>
<tr>
<td align="center">\NNN</td>
<td align="center">The eight-bit character whose value is the octal value NNN (one to three octal digits)</td>
</tr>
<tr>
<td align="center">\xHH</td>
<td align="center">The eight-bit character whose value is the hexadecimal value (one or two hexadecimal digits)</td>
</tr>
</tbody>
</table>
<h3 id="bash">bash变量是无类型的<a class="headerlink" href="#bash" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="c1">#不同与许多其他的编程语言，Bash不以&quot;类型&quot;来区分变量。本质上来说，Bash变量是字符串，但是根据环境的不同，Bash允许变量有整数计算和比较。其中的决定因素是变量的值是不是只含有数字.</span>
<span class="c1">#整数还是字符串？</span>
<span class="nv">var1</span><span class="o">=</span><span class="m">2314</span>
<span class="nb">let</span> <span class="s2">&quot;var1+=1&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;var1=</span><span class="nv">$var1</span><span class="s2">&quot;</span> <span class="c1">#var1仍然是整数</span>

<span class="nv">var2</span><span class="o">=</span><span class="si">${</span><span class="nv">var1</span><span class="p">/23/aa</span><span class="si">}</span> <span class="c1">#将var1中的23替换成aa并赋值给var2，这使var2成为字符串</span>
<span class="nb">echo</span> <span class="s2">&quot;var2=</span><span class="nv">$var2</span><span class="s2">&quot;</span>
<span class="nb">declare</span> -i var2 <span class="c1">#即使明确声明var2是整数也没用</span>
<span class="nb">echo</span> <span class="s2">&quot;var2=</span><span class="nv">$var2</span><span class="s2">&quot;</span>

<span class="nb">let</span> <span class="s2">&quot;var2+=1&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;var2=</span><span class="nv">$var2</span><span class="s2">&quot;</span>

<span class="nv">var3</span><span class="o">=</span>aa14
<span class="nb">echo</span> <span class="s2">&quot;var3=</span><span class="nv">$var3</span><span class="s2">&quot;</span>
<span class="nv">var4</span><span class="o">=</span><span class="si">${</span><span class="nv">var3</span><span class="p">/aa/23</span><span class="si">}</span>

<span class="nb">echo</span> <span class="s2">&quot;var4=</span><span class="nv">$var4</span><span class="s2">&quot;</span>
<span class="nb">let</span> <span class="s2">&quot;var+=1&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;var4=</span><span class="nv">$var4</span><span class="s2">&quot;</span>

<span class="c1">#如果变量是null如何</span>
<span class="nv">var5</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;var5=</span><span class="nv">$var5</span><span class="s2">&quot;</span>
<span class="nb">let</span> <span class="s2">&quot;var5+=1&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;var5=</span><span class="nv">$var5</span><span class="s2">&quot;</span>

<span class="c1">#如果没有声明变量如何</span>
<span class="nb">echo</span> <span class="s2">&quot;var6=</span><span class="nv">$var6</span><span class="s2">&quot;</span>
<span class="nb">let</span> <span class="s2">&quot;var6+=1&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;var6=</span><span class="nv">$var6</span><span class="s2">&quot;</span>

<span class="c1">#结论：在bash中变量确实是无类型的</span>
<span class="nb">exit</span> <span class="m">0</span>
</pre></div>

<h3 id="_16">特殊变量类型<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="c1">#局部变量：只在代码块或一个函数中有效</span>
<span class="c1">#环境变量：其会影响shell的行为和用户接口，大部分情况下，每个进程都有一个环境，其由进程使用的环境变量组成</span>
<span class="c1">#分配给环境变量的总空间有限，若创建太多环境变量或有些环境变量的值太长而占用过多空间则会出错</span>
<span class="c1">#例如：</span>
: <span class="s">&lt;&lt;comment</span>
<span class="s">eval &quot;`seq 10000 | sed -e &#39;s/.*/export var&amp;=ZZZZZZZZZZZZZZ/&#39;`&quot;</span>
<span class="s">du</span>
<span class="s">/usr/bin/du:Argument list too long</span>
<span class="s">comment</span>
<span class="c1">#如果一个脚步要设置一个环境变量，则需要将其导出(export)，也就是讲需通知到脚步的环境表，这是export命令功能</span>
<span class="c1">#一个脚本只能导出（export）变量到子进程，也就是说只能导出到由此脚本生成的命令或进程中。在一个命令行中运行的脚本不能导出一个变量影响到命令行的环境。子进程不能导出变量到生成它的父进程中。</span>
<span class="c1">#位置参数</span>
: <span class="s">&lt;&lt;comment</span>
<span class="s">命令行传递给脚本的参数是$0,$1,$2....</span>
<span class="s">$0是脚本的名字，$1是第一个参数，$2是第二个参数......在位置参数$9之后的参数必须用大括号括起来。如：${10}</span>
<span class="s">特殊变量$*和$@表示所有的位置参数</span>
<span class="s">comment</span>

<span class="c1">#位置参数例子：</span>
: <span class="s">&lt;&lt;comment</span>
<span class="s">#!/bin/bash</span>
<span class="s">#至少以10个参数运行此脚本。例如：./script.sh 1 2 3 4 5 6 7 8 9 10</span>
<span class="s">Minparams=10</span>

<span class="s">echo &quot;脚本名字是\&quot;$0\&quot;.&quot;</span>
<span class="s">#用./表示当前目录</span>
<span class="s">echo &quot;脚本名字是\&quot;`basename $0`\&quot;.&quot;</span>

<span class="s">comment</span>
</pre></div>

<h3 id="_17">转义字符<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="nb">echo</span> <span class="s2">&quot;\v\v\v&quot;</span>

<span class="c1">#用-e选项，echo会打印出转义字符</span>
<span class="nb">echo</span> -e <span class="s2">&quot;\v\v\v&quot;</span>

<span class="c1">#打印出字符&quot; (&quot;引号字符的八进制ASCII码为42)</span>
<span class="nb">echo</span> -e <span class="s2">&quot;\042&quot;</span>

<span class="c1">#当使用像$&#39;\x&#39;的结构时，-e的选项是多余的</span>
<span class="nb">echo</span> <span class="s2">&quot;NEW LINE and BEEP&quot;</span>
<span class="nb">echo</span> <span class="s1">$&#39;\n&#39;</span>  <span class="c1">#新行</span>
<span class="nb">echo</span> <span class="s1">$&#39;\a&#39;</span>  <span class="c1">#警告(峰鸣)</span>

<span class="c1">#版本2开始bash允许使用$&#39;\nnn&#39;结构，这里&#39;\nnn&#39;表示一个八进制的值</span>
<span class="nb">echo</span> <span class="s1">$&#39;\042&#39;</span>

<span class="c1">#使用$&#39;\xnnn&#39;结构也可以使用十六进制来转义</span>
<span class="nb">echo</span> <span class="s1">$&#39;\x22&#39;</span>

<span class="c1">#用ASCII码值把字符赋给变量</span>
<span class="nv">quote</span><span class="o">=</span><span class="s1">$&#39;\042&#39;</span>   <span class="c1">#引号&quot;被赋值给变量quote</span>
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$quote</span><span class="s2"> 这是一个引号字符串&quot;</span>

<span class="c1"># 用连串的ASCII码把一串字符赋给变量..</span>
<span class="nv">triple_underline</span><span class="o">=</span><span class="s1">$&#39;\137\137\137&#39;</span>  <span class="c1"># 137是字符&#39;_&#39;的ASCII码</span>
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$triple_underline</span><span class="s2"> UNDERLINE </span><span class="nv">$triple_underline</span><span class="s2">&quot;</span>

<span class="nv">ABC</span><span class="o">=</span><span class="s1">$&#39;\101\102\103\010&#39;</span> <span class="c1"># 101, 102, 103分别是A, B, C字符的八进制ASCII码.</span>
<span class="nb">echo</span> <span class="nv">$ABC</span>

<span class="nv">escape</span><span class="o">=</span><span class="s1">$&#39;\033&#39;</span>  <span class="c1"># 033是ESC的ASCII码的八进制值</span>
<span class="nb">echo</span> <span class="s2">&quot;\&quot;escape\&quot; echoes as </span><span class="nv">$escape</span><span class="s2">&quot;</span> <span class="c1"># 不可见的输出</span>

一个字符串赋给变量时里面的组成部分可能会被转义，但如果单独一个转义字符（<span class="se">\）</span>是不能赋给变量的。

转义一个空格可以防止一个字符串参数被分割成多个命令行参数。

转义符也提供了写一个多行命令的手段。一般地，每个单独的行有一个不同的命令，而在一行末尾的转义符转义新行符，命令序列则由下一行继续。
</pre></div>

<h3 id="bash_1">bash退出和退出状态<a class="headerlink" href="#bash_1" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>exit命令一般用于结束一个脚本，它也能返回一个值给父进程
每一个命令都能返回一个退出状态（有时也看做返回状态<span class="o">)</span>.一个命令执行成功返回0，一个执行不成功的命令则返回一个非零值，此值通常可以被解释成一个对应的错误值。除了一些例外的情况，一个行为端庄的UNIX命令，程序或是软件包执行成功能返回0的作为退出码。

同样的，在脚本里的函数和脚本自身都会返回一个退出状态码。在脚本或函数里被执行的最后一个命令将决定退出状态码。在一个脚本里，exit nnn 命令将会返回shell一个nnn的退出状态码。（nnn必须是一个在0-255范围的十进制整数）。

如果一个脚本以不带参数的exit命令结束，脚本的退出状态码将会是执行exit命令前的最后一个命令的退出码。

脚本结束没有exit,不带参数的exit和exit <span class="nv">$?</span>三者等价
<span class="nv">$?</span>变量保存了最后一个命令执行后的退出状态，当一个函数返回时，<span class="nv">$?</span>保存了函数里最后一个命令的退出状态码。这就是Bash里函数返回值的处理办法。当一个脚本运行结束，<span class="nv">$?</span> 变量保存脚本的退出状态，而脚本的退出状态则是脚本中最后一个已执行命令的退出状态。并且依照惯例，0表示执行成功，1-255的整数范围表示错误或反常的条件。

逻辑非操作符!，反转一个命令或一个测试的结果。也能反转退出状态
</pre></div>

<h3 id="if">和if一起使用的主要表达式<a class="headerlink" href="#if" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th align="center">主要的</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">[ -a FILE ]</td>
<td align="center">文件如果存在返回True</td>
</tr>
<tr>
<td align="center">[ -b FILE ]</td>
<td align="center">文件如果存在并且是块设备返回True(软盘,光驱等)</td>
</tr>
<tr>
<td align="center">[ -c FILE ]</td>
<td align="center">文件如果存在并且时字符设备返回True(键盘,调制解调器,声卡等)</td>
</tr>
<tr>
<td align="center">[ -d FILE ]</td>
<td align="center">如果是目录返回True</td>
</tr>
<tr>
<td align="center">[ -e FILE ]</td>
<td align="center">文件如果存在返回True</td>
</tr>
<tr>
<td align="center">[ -f FILE ]</td>
<td align="center">文件是普通文件并且不是一个目录或是一个设备文件返回True</td>
</tr>
<tr>
<td align="center">[ -g FILE ]</td>
<td align="center">文件如果存在并且文件或目录的设置-组-ID(sgid)标记被设置返回True，如果一个目录的sgid标志被设置，在这个目录下创建的文件都属于拥有此目录的用户组，而不必是创建文件的用户所属的组。这个特性对在一个工作组里的同享目录很有用处</td>
</tr>
<tr>
<td align="center">[ -h FILE ]</td>
<td align="center">文件如果存在并且是个符号链接返回True</td>
</tr>
<tr>
<td align="center">[ -k FILE ]</td>
<td align="center">文件如果存在返回True and 粘住位设置。俗称“粘性位”，保存文本模式标志是一种特殊类型的文件权限。如果一个文件设置了这个标志，该文件将被保存在缓存内存中，以便更快地访问。〔2〕如果设置在目录上，则限制写入权限。设置粘性位将T添加到文件或目录列表的权限(drwxrwxrw**t**)，如果用户不拥有设置了粘性位的目录，但在该目录中具有写权限，则他只能删除其拥有的目录中的文件。这样可以防止用户在公共可访问目录（如/tMP）中无意中覆盖或删除彼此的文件</td>
</tr>
<tr>
<td align="center">[ -p FILE ]</td>
<td align="center">文件如果存在并且文件是一个管道返回True</td>
</tr>
<tr>
<td align="center">[ -r FILE ]</td>
<td align="center">文件如果存在并且文件是否可读返回True(指运行这个测试命令的用户的读权限)</td>
</tr>
<tr>
<td align="center">[ -s FILE ]</td>
<td align="center">文件如果存在并且文件大小大于0返回True</td>
</tr>
<tr>
<td align="center">[ -t FD ]</td>
<td align="center">如果一个文件描述符FD(对应函数的返回值)打开并引用了终端则为True，文件(描述符)与一个终端设备相关，这个测试选项可以用于检查脚本中是否标准输入 ([ -t 0 ])或标准输出([ -t 1 ])是一个终端</td>
</tr>
<tr>
<td align="center">[ -u FILE ]</td>
<td align="center">文件如果存在返回True，文件的设置-用户-ID(suid)标志被设置，一个root用户拥有的二进制执行文件如果设置了设置-用户-ID位(suid)标志普通用户可以以root权限运行。[1] 这对需要存取系统硬件的执行程序（比如说pppd和cdrecord）很有用。如果没有设置suid位，则这些二进制执行程序不能由非root的普通用户调用。被设置了suid标志的文件在权限列中以s标志表示(-rw**s**r-xr-t)</td>
</tr>
<tr>
<td align="center">[ -w FILE ]</td>
<td align="center">文件如果存在并且可写的返回True(运行这个测试命令的用户的写权限)</td>
</tr>
<tr>
<td align="center">[ -x FILE ]</td>
<td align="center">文件如果存在并且是可执行的返回(测试命令的用户的执行权限)</td>
</tr>
<tr>
<td align="center">[ -O FILE ]</td>
<td align="center">文件如果存在并且由有效用户ID所拥有的返回True(你是文件拥有者)</td>
</tr>
<tr>
<td align="center">[ -G FILE ]</td>
<td align="center">文件如果存在并且由用户组ID所拥有的返回True(你所在的组和文件的groupID一致)</td>
</tr>
<tr>
<td align="center">[ -L FILE ]</td>
<td align="center">文件如果存在并且是一个符号链接返回True</td>
</tr>
<tr>
<td align="center">[ -N FILE ]</td>
<td align="center">文件如果存在并且最后一次读后被修改返回True</td>
</tr>
<tr>
<td align="center">[ -S FILE ]</td>
<td align="center">文件如果存在并且是一个socket返回True</td>
</tr>
<tr>
<td align="center">[ FILE1 -nt FILE2 ]</td>
<td align="center">如果FILE1比FILE2更新，或者FILE1存在且FILE2不存在，则为True</td>
</tr>
<tr>
<td align="center">[ FILE1 -ot FILE2 ]</td>
<td align="center">如果FILE1比FILE2旧，或者FILE2存在且FILE1不存在，则为True</td>
</tr>
<tr>
<td align="center">[ FILE1 -ef FILE2 ]</td>
<td align="center">如果FILE1和FILE2引用相同的设备和inode编号(相同的文件硬链接)，则为True</td>
</tr>
<tr>
<td align="center">[ -o OPTIONNAME ]</td>
<td align="center">如果启用了shell选项“OPTIONNAME”(选项名称)，则为True</td>
</tr>
<tr>
<td align="center">[ -z STRING ]</td>
<td align="center">如果字符串为0则为True</td>
</tr>
<tr>
<td align="center">[ -n STRING ] or [ STRING ]</td>
<td align="center">如果字符串不为0则为True</td>
</tr>
<tr>
<td align="center">[ STRING1 == STRING2 ]</td>
<td align="center">如果字符串相等则为True，对于严格的POSIX合规性，可以使用“=”代替“==”</td>
</tr>
<tr>
<td align="center">[ STRING1 != STRING2 ]</td>
<td align="center">如果字符串不相等则为True</td>
</tr>
<tr>
<td align="center">[ STRING1 &lt; STRING2 ]</td>
<td align="center">如果“STRING1”在当前locale环境中按字典顺序在“STRING2”之前排序，则为True</td>
</tr>
<tr>
<td align="center">[ STRING1 &gt; STRING2 ]</td>
<td align="center">如果“STRING1”在当前locale环境中按字典顺序在“STRING2”之后排序，则为True</td>
</tr>
<tr>
<td align="center">[ ARG1 OP ARG2 ]</td>
<td align="center">“OP”是-eq，-ne，-lt，-le，-gt或-ge之一。 如果“ARG1”分别等于，不等于，小于，小于或等于，大于或大于或等于“ARG2”，则这些算术二元运算符返回true。 “ARG1”和“ARG2”是整数</td>
</tr>
</tbody>
</table>
<p>可以使用以下运算符组合表达式，按优先级递减顺序列出：
结合表达式
| 类别 | 例子 |
| :------: | :------: |
| [ ! EXPR ] | "非" -- 反转上面所有测试的结果(如果没有给出条件则返回真),如果EXPR是false则为真 |
| [ ( EXPR ) ] | 返回EXPR的值。 这可以用于覆盖运算符的正常优先级 |
| [ EXPR1 -a EXPR2 ] | 如果EXPR1和EXPR2都为真，则为真 |
| [ EXPR1 -o EXPR2 ] | 如果EXPR1或EXPR2为真，则为真 |</p>
<p>大多数程序员更喜欢使用test内置命令，这相当于使用方括号进行比较，如下所示</p>
<div class="codehilite"><pre><span></span><span class="nb">test</span> <span class="s2">&quot;</span><span class="k">$(</span>whoami<span class="k">)</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s1">&#39;root&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="nb">echo</span> you are using a non-privileged account<span class="p">;</span> <span class="nb">exit</span> <span class="m">1</span><span class="o">)</span>

如果在子shell中调用exit，则不会将变量传递给父级。如果您不希望Bash派生子shell，请使用<span class="o">{</span> <span class="o">}</span>代替<span class="o">()</span>
</pre></div>

<h3 id="if_1">if语句[ ] [[ ]]比较<a class="headerlink" href="#if_1" title="Permanent link">&para;</a></h3>
<p>[] vs [[]]</p>
<p>Contrary to [, [[ prevents word splitting of variable values. So, if VAR="var with spaces", you do not need to double quote $VAR in a test - eventhough using quotes remains a good habit. Also, [[ prevents pathname expansion, so literal strings with wildcards do not try to expand to filenames. Using [[, == and != interpret strings to the right as shell glob patterns to be matched against the value to the left, for instance: [[ "value" == val* ]]</p>
<table>
<thead>
<tr>
<th align="center">测试类型</th>
<th align="center">[ ]</th>
<th align="center">[[ ]]</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">数字测试</td>
<td align="center">-eq -ne -lt -le -gt -ge</td>
<td align="center">同[ ]</td>
</tr>
<tr>
<td align="center">文件测试</td>
<td align="center">-r -l -w -x -f -d -s -nt -ot</td>
<td align="center">同[ ]</td>
</tr>
<tr>
<td align="center">字符测试</td>
<td align="center">= != -n -z ==(同=) 不可使用&lt;= &gt;=</td>
<td align="center">同[ ]</td>
</tr>
<tr>
<td align="center">逻辑测试</td>
<td align="center">-a -o !</td>
<td align="center">&amp;&amp; || !</td>
</tr>
<tr>
<td align="center">数学运算</td>
<td align="center">不可以使用</td>
<td align="center">+ - * / %</td>
</tr>
<tr>
<td align="center">组合</td>
<td align="center">用各自逻辑符号连接的数字(运算)测试、文件测试、字符测试</td>
<td align="center">同[ ]</td>
</tr>
</tbody>
</table>
<p>情况较复杂的字符测试</p>
<table>
<thead>
<tr>
<th align="center">字符测试</th>
<th align="center">[ ]</th>
<th align="center">[[ ]]</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&lt; &gt;</td>
<td align="center">比较结果异常，如:<span><span class="MathJax_Preview">[ 12 &gt; 21 ]与</span><script type="math/tex">[ 12 > 21 ]与</script></span>[ 21 &gt; 12 ]、<span><span class="MathJax_Preview">[ a &gt; b ]与</span><script type="math/tex">[ a > b ]与</script></span>[ b &gt; a ]的返回值一样</td>
<td align="center">根据对于ASCII码进行比较(若多个字母和数字组合，则先比较首个，相同再比较下一个)</td>
</tr>
<tr>
<td align="center">\&gt; \&lt;</td>
<td align="center">根据对于ASCII码进行比较(若多个字母和数字组合，则先比较首个，相同再比较下一个)</td>
<td align="center">不可以使用</td>
</tr>
</tbody>
</table>
<h3 id="ifthenelse">if/then/else构造<a class="headerlink" href="#ifthenelse" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="c1"># 测试断掉的连接</span>

<span class="c1">#!/bin/bash</span>
<span class="c1"># broken-link.sh</span>
<span class="c1"># 由Lee bigelow所写&lt;ligelowbee@yahoo.com&gt;</span>

<span class="c1">#一个用于发现死符号链接并且输出它们的链接文件的纯shell的脚本。</span>
<span class="c1">#所以它们能把输出提供给xargs并处理 :)</span>
<span class="c1">#例如： broken-link.sh /somedir /someotherdir|xargs rm</span>
<span class="c1">#</span>
<span class="c1">#下面是更好的发现死符号链接的办法:</span>
<span class="c1">#</span>
<span class="c1">#find &quot;somedir&quot; -type l -print0|\</span>
<span class="c1">#xargs -r0 file|\</span>
<span class="c1">#grep &quot;broken symbolic&quot;|</span>
<span class="c1">#sed -e &#39;s/^\|: *broken symbolic.*$/&quot;/g&#39;</span>
<span class="c1">#</span>
<span class="c1">#但这不是纯bash脚本，下面的则是.</span>
<span class="c1">#注意: 谨防在/proc文件系统和死循环链接中使用!</span>
<span class="c1">###############################################</span>


<span class="c1">#如果没有参数被传递给脚本作为搜索目录，则使用当前目录</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">###############</span>
<span class="o">[</span> <span class="nv">$#</span> -eq <span class="m">0</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nv">directorys</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span> <span class="o">||</span> <span class="nv">directorys</span><span class="o">=</span><span class="nv">$@</span>

<span class="c1">#Setup the function linkchk to check the directory it is passed</span>
<span class="c1">#for files that are links and don&#39;t exist, then print them quoted.</span>
<span class="c1">#If one of the elements in the directory is a subdirectory then</span>
<span class="c1">#send that send that subdirectory to the linkcheck function.</span>
<span class="c1">########</span>
linkchk <span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> element in <span class="nv">$1</span>/*<span class="p">;</span> <span class="k">do</span>
    <span class="o">[</span> -h <span class="s2">&quot;</span><span class="nv">$element</span><span class="s2">&quot;</span> -a ! -e <span class="s2">&quot;</span><span class="nv">$element</span><span class="s2">&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="se">\&quot;</span><span class="nv">$element</span><span class="se">\&quot;</span>
    <span class="o">[</span> -d <span class="s2">&quot;</span><span class="nv">$element</span><span class="s2">&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> linkchk <span class="nv">$element</span>
    <span class="c1"># Of course, &#39;-h&#39; tests for symbolic link, &#39;-d&#39; for directory.</span>
    <span class="k">done</span>
<span class="o">}</span>

<span class="c1">#Send each arg that was passed to the script to the linkchk function</span>
<span class="c1">#if it is a valid directoy.  If not, then print the error message</span>
<span class="c1">#and usage info.</span>
<span class="c1">############</span>
<span class="k">for</span> directory in <span class="nv">$directorys</span><span class="p">;</span> <span class="k">do</span>
    <span class="k">if</span> <span class="o">[</span> -d <span class="nv">$directory</span> <span class="o">]</span>
    <span class="k">then</span> linkchk <span class="nv">$directory</span>
    <span class="k">else</span>
        <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$directory</span><span class="s2"> is not a directory&quot;</span>
        <span class="nb">echo</span> <span class="s2">&quot;Usage: </span><span class="nv">$0</span><span class="s2"> dir1 dir2 ...&quot;</span>
    <span class="k">fi</span>
<span class="k">done</span>

<span class="o">[</span><span class="m">1</span><span class="o">]</span> 一定要意识到suid二进制文件可能引起潜在的安全漏洞，并且在shell脚本中suid标志已经不起作用了。
<span class="o">[</span><span class="m">2</span><span class="o">]</span> 在现代UNIX操作系统，粘住位已经不在文件中再使用，只用在目录中
</pre></div>

<h3 id="then">then语句后面的命令<a class="headerlink" href="#then" title="Permanent link">&para;</a></h3>
<p>then语句后面的CONSEQUENT-COMMANDS列表可以是任何有效的UNIX命令，任何可执行程序，任何可执行shell脚本或任何shell语句，但结束fi除外。重要的是要记住，then和fi被认为是shell中的分隔语句。因此，在命令行上发出时，它们用分号分隔。</p>
<div class="codehilite"><pre><span></span><span class="c1">#第一个示例检查文件是否存在</span>
<span class="c1">#!/bin/bash</span>

<span class="nb">echo</span> <span class="s2">&quot;This scripts checks the existence of the messages file.&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;Checking...&quot;</span>
<span class="k">if</span> <span class="o">[</span> -f /var/log/messages <span class="o">]</span>
  <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;/var/log/messages exists.&quot;</span>
<span class="k">fi</span>
<span class="nb">echo</span>
<span class="nb">echo</span> <span class="s2">&quot;...done.&quot;</span>
</pre></div>

<div class="codehilite"><pre><span></span>一个if/then结构测试一列命令的退出状态是否为0（因为依照惯例，0意味着命令执行成功），如果是0则会执行一个或多个命令。

有一个命令 <span class="o">[</span> <span class="o">(</span>左方括是特殊字符<span class="o">)</span>. 它和test是同义词,因为效率的原因，它被内建在shell里。这个命令的参数是比较表达式或者文件测试，它会返回一个退出状态指示比较的结果<span class="o">(</span>0表示真，1表示假<span class="o">)</span>。

<span class="c1">#一个if/then结构能包含嵌套的比较和测试。</span>
<span class="k">if</span> <span class="nb">echo</span> <span class="s2">&quot;Next *if* is part of the comparison for the first *if*.&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> <span class="nv">$comparison</span> <span class="o">=</span> <span class="s2">&quot;integer&quot;</span> <span class="o">]]</span>
    <span class="k">then</span> <span class="o">((</span> a &lt; b <span class="o">))</span>
  <span class="k">else</span>
    <span class="o">[[</span> <span class="nv">$a</span> &lt; <span class="nv">$b</span> <span class="o">]]</span>
  <span class="k">fi</span>

<span class="k">then</span>
  <span class="nb">echo</span> <span class="s1">&#39;$a is less than $b&#39;</span>
<span class="k">fi</span>

<span class="c1">#if基本结构</span>
<span class="k">if</span> <span class="o">[</span> condition-true <span class="o">]</span>
<span class="k">then</span>
   <span class="nb">command</span> <span class="m">1</span>
   <span class="nb">command</span> <span class="m">2</span>
   ...
<span class="k">else</span>
   <span class="c1"># 或选的(如果不需要就可去掉).</span>
   <span class="c1"># 如果条件测试失败，就在这里加入默认的执行命令.</span>
   <span class="nb">command</span> <span class="m">3</span>
   <span class="nb">command</span> <span class="m">4</span>
   ...
<span class="k">fi</span>

当if和then在同一行的时候，一个分号（<span class="p">;</span>）必须用在if语句的结尾。if和then都是关键字.关键字（或命令）开始一个语句，如果在同一行开始另一个新语句时，前面一个语句必须用分号（<span class="p">;</span>）结束。
<span class="k">if</span> <span class="o">[</span> -x <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>

<span class="c1">#等价的测试命令：test,/usr/bin/test,[]和/usr/bin/[</span>
<span class="c1">#!/bin/bash</span>

<span class="nb">echo</span>

<span class="k">if</span> <span class="nb">test</span> -z <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;No command-line arguments.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;First command-line argument is </span><span class="nv">$1</span><span class="s2">.&quot;</span>
<span class="k">fi</span>

<span class="nb">echo</span>

<span class="k">if</span> /usr/bin/test -z <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>      <span class="c1"># 和内建的&quot;test&quot;命令一样.</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;No command-line arguments.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;First command-line argument is </span><span class="nv">$1</span><span class="s2">.&quot;</span>
<span class="k">fi</span>

<span class="nb">echo</span>

<span class="k">if</span> <span class="o">[</span> -z <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">]</span>                <span class="c1"># 和上面代码块的功能一样</span>
<span class="c1">#   if [ -z &quot;$1&quot;                应该来说会运行, 但是...</span>
<span class="c1">#+  Bash给出错误说少了一个封闭的右方括.</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;No command-line arguments.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;First command-line argument is </span><span class="nv">$1</span><span class="s2">.&quot;</span>
<span class="k">fi</span>

<span class="nb">echo</span>


<span class="k">if</span> /usr/bin/<span class="o">[</span> -z <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">]</span>       <span class="c1"># 同样和上面的代码块一样.</span>
<span class="c1"># if /usr/bin/[ -z &quot;$1&quot;       # 工作, 但还是给出一个错误信息.</span>
<span class="c1">#                             # 注意:</span>
<span class="c1">#                               这个已经在bash 3.x版本被修补好了。</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;No command-line arguments.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;First command-line argument is </span><span class="nv">$1</span><span class="s2">.&quot;</span>
<span class="k">fi</span>

在<span class="o">[[</span>和<span class="o">]]</span>之间的所有的字符都不会被文件扩展或是标记分割，但是会有参数引用和命令替换。
<span class="nv">file</span><span class="o">=</span>/etc/passwd

<span class="k">if</span> <span class="o">[[</span> -e <span class="nv">$file</span> <span class="o">]]</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Password file exists.&quot;</span>
<span class="k">fi</span>

用<span class="o">[[</span> ... <span class="o">]]</span>测试结构比用<span class="o">[</span> ... <span class="o">]</span>更能防止脚本里的许多逻辑错误。比如说，<span class="o">&amp;&amp;</span>,<span class="o">||</span>,&lt;和&gt;操作符能在一个<span class="o">[[]]</span>测试里通过，但在<span class="o">[]</span>结构会发生错误。

在一个if的后面，不必一定是test命令或是test结构（<span class="o">[]</span>或是<span class="o">[[]]</span>）。
<span class="nv">dir</span><span class="o">=</span>/home/bozo

<span class="k">if</span> <span class="nb">cd</span> <span class="s2">&quot;</span><span class="nv">$dir</span><span class="s2">&quot;</span> <span class="m">2</span>&gt;/dev/null<span class="p">;</span> <span class="k">then</span>   <span class="c1"># &quot;2&gt;/dev/null&quot;会隐藏错误的信息.</span>
  <span class="nb">echo</span> <span class="s2">&quot;Now in </span><span class="nv">$dir</span><span class="s2">.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;Can&#39;t change to </span><span class="nv">$dir</span><span class="s2">.&quot;</span>
<span class="k">fi</span>
<span class="s2">&quot;if COMMAND&quot;</span>结构会返回COMMAND命令的退出状态码。

同样的，在一个测试方括号里面的条件测试也可以用列表结构<span class="o">(</span>list construct<span class="o">)</span>而不必用if。
<span class="nv">var1</span><span class="o">=</span><span class="m">20</span>
<span class="nv">var2</span><span class="o">=</span><span class="m">22</span>
<span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$var1</span><span class="s2">&quot;</span> -ne <span class="s2">&quot;</span><span class="nv">$var2</span><span class="s2">&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$var1</span><span class="s2"> is not equal to </span><span class="nv">$var2</span><span class="s2">&quot;</span>

<span class="nv">home</span><span class="o">=</span>/home/bozo
<span class="o">[</span> -d <span class="s2">&quot;</span><span class="nv">$home</span><span class="s2">&quot;</span> <span class="o">]</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$home</span><span class="s2"> directory does not exist.&quot;</span>

<span class="o">((</span> <span class="o">))</span>结构扩展并计算一个算术表达式的值。如果表达式值为0，会返回1或假作为退出状态码。一个非零值的表达式返回一个0或真作为退出状态码。这个结构和先前test命令及<span class="o">[]</span>结构的讨论刚好相反。

<span class="c1">#用(( ))进行算术测试</span>
<span class="c1">#!/bin/bash</span>
<span class="c1"># 算术测试.</span>

<span class="c1"># (( ... ))结构会求值并测试该值。</span>
<span class="c1"># 退出状态码与[ ... ]结构正好相反!</span>

<span class="o">((</span> <span class="m">0</span> <span class="o">))</span>
<span class="nb">echo</span> <span class="s2">&quot;Exit status of \&quot;(( 0 ))\&quot; is </span><span class="nv">$?</span><span class="s2">.&quot;</span>         <span class="c1"># 1</span>

<span class="o">((</span> <span class="m">1</span> <span class="o">))</span>
<span class="nb">echo</span> <span class="s2">&quot;Exit status of \&quot;(( 1 ))\&quot; is </span><span class="nv">$?</span><span class="s2">.&quot;</span>         <span class="c1"># 0</span>

<span class="o">((</span> <span class="m">5</span> &gt; <span class="m">4</span> <span class="o">))</span>                                      <span class="c1"># 真</span>
<span class="nb">echo</span> <span class="s2">&quot;Exit status of \&quot;(( 5 &gt; 4 ))\&quot; is </span><span class="nv">$?</span><span class="s2">.&quot;</span>     <span class="c1"># 0</span>

<span class="o">((</span> <span class="m">5</span> &gt; <span class="m">9</span> <span class="o">))</span>                                      <span class="c1"># 假</span>
<span class="nb">echo</span> <span class="s2">&quot;Exit status of \&quot;(( 5 &gt; 9 ))\&quot; is </span><span class="nv">$?</span><span class="s2">.&quot;</span>     <span class="c1"># 1</span>

<span class="o">((</span> <span class="m">5</span> - <span class="m">5</span> <span class="o">))</span>                                      <span class="c1"># 0</span>
<span class="nb">echo</span> <span class="s2">&quot;Exit status of \&quot;(( 5 - 5 ))\&quot; is </span><span class="nv">$?</span><span class="s2">.&quot;</span>     <span class="c1"># 1</span>

<span class="o">((</span> <span class="m">5</span> / <span class="m">4</span> <span class="o">))</span>                                      <span class="c1"># 除法有效.</span>
<span class="nb">echo</span> <span class="s2">&quot;Exit status of \&quot;(( 5 / 4 ))\&quot; is </span><span class="nv">$?</span><span class="s2">.&quot;</span>     <span class="c1"># 0</span>

<span class="o">((</span> <span class="m">1</span> / <span class="m">2</span> <span class="o">))</span>                                      <span class="c1"># 除法计算结果&lt; 1</span>
<span class="nb">echo</span> <span class="s2">&quot;Exit status of \&quot;(( 1 / 2 ))\&quot; is </span><span class="nv">$?</span><span class="s2">.&quot;</span>     <span class="c1"># 截取为0.</span>
                                                 <span class="c1"># 1</span>

<span class="o">((</span> <span class="m">1</span> / <span class="m">0</span> <span class="o">))</span> <span class="m">2</span>&gt;/dev/null                          <span class="c1"># 除以0的非法计算.</span>
<span class="c1">#           ^^^^^^^^^^^</span>
<span class="nb">echo</span> <span class="s2">&quot;Exit status of \&quot;(( 1 / 0 ))\&quot; is </span><span class="nv">$?</span><span class="s2">.&quot;</span>     <span class="c1"># 1</span>
</pre></div>

<h3 id="_18">其他比较操作符<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>二元比较操作符比较两个变量或是数值。注意整数和字符串比较的分别。

整数比较

-eq

等于

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> -eq <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

-ne
不等于

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> -ne <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

-gt
大于

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> -gt <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

-ge
大于等于

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> -ge <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

-lt
小于

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> -lt <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

-le
小于等于

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> -le <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

&lt;
小于<span class="o">(</span>在双括号里使用<span class="o">)</span>

<span class="o">((</span><span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> &lt; <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span><span class="o">))</span>

&lt;<span class="o">=</span>
小于等于 <span class="o">(</span>在双括号里使用<span class="o">)</span>

<span class="o">((</span><span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> &lt;<span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span><span class="o">))</span>

&gt;
大于 <span class="o">(</span>在双括号里使用<span class="o">)</span>

<span class="o">((</span><span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> &gt; <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span><span class="o">))</span>

&gt;<span class="o">=</span>
大于等于<span class="o">(</span>在双括号里使用<span class="o">)</span>

<span class="o">((</span><span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> &gt;<span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span><span class="o">))</span>

<span class="nv">字符串比较</span>

<span class="o">=</span>

等于

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

<span class="o">==</span>
等于

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

<span class="nv">它和</span><span class="o">=</span>是同义词。

<span class="o">==</span>比较操作符在一个双方括号测试和一个单方括号号里意思不同。
<span class="o">[[</span> <span class="nv">$a</span> <span class="o">==</span> z* <span class="o">]]</span>    <span class="c1"># 如果变量$a以字符&quot;z&quot;开始(模式匹配)则为真.</span>
<span class="o">[[</span> <span class="nv">$a</span> <span class="o">==</span> <span class="s2">&quot;z*&quot;</span> <span class="o">]]</span>  <span class="c1"># 如果变量$a与z*(字面上的匹配)相等则为真.</span>

<span class="o">[</span> <span class="nv">$a</span> <span class="o">==</span> z* <span class="o">]</span>      <span class="c1"># 文件扩展和单元分割有效.</span>
<span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="s2">&quot;z*&quot;</span> <span class="o">]</span>  <span class="c1"># 如果变量$a与z*(字面上的匹配)相等则为真.</span>

!<span class="o">=</span>
不相等

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

操作符在<span class="o">[[</span> ... <span class="o">]]</span>结构里使用模式匹配.

&lt;
小于，依照ASCII字符排列顺序

<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> &lt; <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]]</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> <span class="se">\&lt;</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

注意<span class="s2">&quot;&lt;&quot;</span>字符在<span class="o">[</span> <span class="o">]</span> 结构里需要转义

&gt;
大于，依照ASCII字符排列顺序

<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> &gt; <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]]</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> <span class="se">\&gt;</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>

注意<span class="s2">&quot;&gt;&quot;</span>字符在<span class="o">[</span> <span class="o">]</span> 结构里需要转义.

参考例子 <span class="m">26</span>-11 中这种比较的一个应用.

-z
字符串为<span class="s2">&quot;null&quot;</span>，即是指字符串长度为零。

-n
字符串不为<span class="s2">&quot;null&quot;</span>，即长度不为零.

在测试方括号里进行-n测试时一定要把字符串用引号起来。用没有引号引起的! -z或者在方括号里只有未引号引起的字符串 <span class="o">(</span>参考例子 <span class="m">7</span>-6<span class="o">)</span>来进行测试一般都能工作，然而，这其实是不安全的测试。应该总是用引号把测试字符串引起来。<span class="o">[</span><span class="m">1</span><span class="o">]</span>
<span class="o">[</span><span class="m">1</span><span class="o">]</span> 就像S.C.指出的那样，在一个混合测试中，把一个字符串变量引号引起来可能还不够。如果<span class="nv">$string变量是空的话</span>，表达式<span class="o">[</span> -n <span class="s2">&quot;</span><span class="nv">$string</span><span class="s2">&quot;</span> -o <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>在一些Bash版本中可能会引起错误。安全的办法是附加一个外部的字符串给可能有空字符串变量比较的所有变量，<span class="o">[</span> <span class="s2">&quot;x</span><span class="nv">$string</span><span class="s2">&quot;</span> !<span class="o">=</span> x -o <span class="s2">&quot;x</span><span class="nv">$a</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;x</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">](</span>x字符可以互相抵消<span class="o">)</span>。

<span class="c1">#算术和字符串比较</span>
<span class="c1">#!/bin/bash</span>

<span class="nv">a</span><span class="o">=</span><span class="m">4</span>
<span class="nv">b</span><span class="o">=</span><span class="m">5</span>

<span class="c1">#  这儿的&quot;a&quot;和&quot;b&quot;既能被看成是整数也能被看着是字符串。</span>
<span class="c1">#  在字符串和数字之间不是严格界定的，</span>
<span class="c1">#+ 因为Bash变量不是强类型的。</span>

<span class="c1">#  Bash允许变量的整数操作和比较，</span>
<span class="c1">#+ 但这些变量必须只包括数字字符.</span>
<span class="c1">#  不管怎么样，你应该小心考虑.</span>

<span class="nb">echo</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> -ne <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2"> is not equal to </span><span class="nv">$b</span><span class="s2">&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;(arithmetic comparison)&quot;</span>
<span class="k">fi</span>

<span class="nb">echo</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> !<span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">]</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2"> is not equal to </span><span class="nv">$b</span><span class="s2">.&quot;</span>
  <span class="nb">echo</span> <span class="s2">&quot;(string comparison)&quot;</span>
  <span class="c1">#     &quot;4&quot;  != &quot;5&quot;</span>
  <span class="c1"># ASCII 52 != ASCII 53</span>
<span class="k">fi</span>
<span class="c1"># 在这个实际的例子中,&quot;-ne&quot;和&quot;!=&quot;都能工作</span>


<span class="c1">#测试一个字符串是否是null值</span>
<span class="c1">#!/bin/bash</span>
<span class="c1">#  str-test.sh: 测试null字符串和没有用引号引起的字符串,</span>
<span class="c1">#+ but not strings and sealing wax, not to mention cabbages and kings . .</span>

<span class="c1"># 用if [ ... ]结构</span>


<span class="c1"># 如果一个字符串变量没有被初始化，它里面的值未定义。</span>
<span class="c1"># 这种情况称为&quot;null&quot;值(不同于零).</span>

<span class="k">if</span> <span class="o">[</span> -n <span class="nv">$string1</span> <span class="o">]</span>    <span class="c1"># $string1没有被声明或初始化.</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;String \&quot;string1\&quot; is not null.&quot;</span>
<span class="k">else</span>  
  <span class="nb">echo</span> <span class="s2">&quot;String \&quot;string1\&quot; is null.&quot;</span>
<span class="k">fi</span>  
<span class="c1"># 错误结果.</span>
<span class="c1"># Shows $string1 as not null, although it was not initialized.</span>


<span class="nb">echo</span>


<span class="c1"># 让我们再试试.</span>

<span class="k">if</span> <span class="o">[</span> -n <span class="s2">&quot;</span><span class="nv">$string1</span><span class="s2">&quot;</span> <span class="o">]</span>  <span class="c1"># 这次, $string1变量被引号引起.</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;String \&quot;string1\&quot; is not null.&quot;</span>
<span class="k">else</span>  
  <span class="nb">echo</span> <span class="s2">&quot;String \&quot;string1\&quot; is null.&quot;</span>
<span class="k">fi</span>                    <span class="c1"># 在一个测试方括里用引号引起变量!</span>


<span class="nb">echo</span>


<span class="k">if</span> <span class="o">[</span> <span class="nv">$string1</span> <span class="o">]</span>       <span class="c1"># 这次,变量$string1什么也不加.</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;String \&quot;string1\&quot; is not null.&quot;</span>
<span class="k">else</span>  
  <span class="nb">echo</span> <span class="s2">&quot;String \&quot;string1\&quot; is null.&quot;</span>
<span class="k">fi</span>  
<span class="c1"># This works fine.</span>
<span class="c1"># The [ ] test operator alone detects whether the string is null.</span>
<span class="c1"># However it is good practice to quote it (&quot;$string1&quot;).</span>
<span class="c1">#</span>
<span class="c1"># As Stephane Chazelas points out,</span>
<span class="c1">#    if [ $string1 ]    has one argument, &quot;]&quot;</span>
<span class="c1">#    if [ &quot;$string1&quot; ]  has two arguments, the empty &quot;$string1&quot; and &quot;]&quot;</span>

<span class="nv">string1</span><span class="o">=</span>initialized

<span class="k">if</span> <span class="o">[</span> <span class="nv">$string1</span> <span class="o">]</span>       <span class="c1"># Again, $string1 stands naked.</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;String \&quot;string1\&quot; is not null.&quot;</span>
<span class="k">else</span>  
  <span class="nb">echo</span> <span class="s2">&quot;String \&quot;string1\&quot; is null.&quot;</span>
<span class="k">fi</span>  
<span class="c1"># Again, gives correct result.</span>
<span class="c1"># Still, it is better to quote it (&quot;$string1&quot;), because . . .</span>


<span class="nv">string1</span><span class="o">=</span><span class="s2">&quot;a = b&quot;</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$string1</span> <span class="o">]</span>       <span class="c1"># Again, $string1 stands naked.</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;String \&quot;string1\&quot; is not null.&quot;</span>
<span class="k">else</span>  
  <span class="nb">echo</span> <span class="s2">&quot;String \&quot;string1\&quot; is null.&quot;</span>
<span class="k">fi</span>  
<span class="c1"># Not quoting &quot;$string1&quot; now gives wrong result!</span>


<span class="c1">#例子：zmore</span>
<span class="c1">#!/bin/bash</span>
<span class="c1"># zmore</span>

<span class="c1">#用&#39;more&#39;查看被压缩过的文件</span>

<span class="nv">NOARGS</span><span class="o">=</span><span class="m">65</span>
<span class="nv">NOTFOUND</span><span class="o">=</span><span class="m">66</span>
<span class="nv">NOTGZIP</span><span class="o">=</span><span class="m">67</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$#</span> -eq <span class="m">0</span> <span class="o">]</span> <span class="c1"># 等同于:  if [ -z &quot;$1&quot; ]</span>
<span class="c1"># $1可以存在,但为空:  zmore &quot;&quot; arg2 arg3</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Usage: `basename </span><span class="nv">$0</span><span class="s2">` filename&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="c1"># 错误信息打印到标准错误.</span>
  <span class="nb">exit</span> <span class="nv">$NOARGS</span>
  <span class="c1"># 返回65作为脚本的退出状态(错误码).</span>
<span class="k">fi</span>  

<span class="nv">filename</span><span class="o">=</span><span class="nv">$1</span>

<span class="k">if</span> <span class="o">[</span> ! -f <span class="s2">&quot;</span><span class="nv">$filename</span><span class="s2">&quot;</span> <span class="o">]</span>   <span class="c1"># Quoting $filename allows for possible ces.</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;File </span><span class="nv">$filename</span><span class="s2"> not found!&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="c1"># 错误信息打印到标准错误.</span>
  <span class="nb">exit</span> <span class="nv">$NOTFOUND</span>
<span class="k">fi</span>  

<span class="k">if</span> <span class="o">[</span> <span class="si">${</span><span class="nv">filename</span><span class="p">##*.</span><span class="si">}</span> !<span class="o">=</span> <span class="s2">&quot;gz&quot;</span> <span class="o">]</span>
<span class="c1"># 在方括号里使用变量替换.</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;File </span><span class="nv">$1</span><span class="s2"> is not a gzipped file!&quot;</span>
  <span class="nb">exit</span> <span class="nv">$NOTGZIP</span>
<span class="k">fi</span>  

zcat <span class="nv">$1</span> <span class="p">|</span> more

<span class="c1"># 用过滤程序&#39;more.&#39;</span>
<span class="c1"># 如果你想，也可以用&#39;less&#39;代替。</span>

<span class="nb">exit</span> <span class="nv">$?</span>   <span class="c1"># 脚本返回管道的退出状态</span>
<span class="c1"># 实际上&quot;exit $?&quot;是多余的,因为在任何情况下，</span>
<span class="c1"># 脚本会返回最后一个执行命令的退出码。</span>


<span class="c1">#混合比较</span>
-a
逻辑与

如果exp1和exp2都为真，则exp1 -a exp2返回真.

-o
逻辑或

只要exp1和exp2任何一个为真，则exp1 -o exp2 返回真.

它们和Bash中用于双方括号结构的比较操作符<span class="o">&amp;&amp;</span>和<span class="o">||</span>很相似。
   <span class="m">1</span> <span class="o">[[</span> condition1 <span class="o">&amp;&amp;</span> condition2 <span class="o">]]</span>
-o和-a操作符和test命令或单方括号一起使用。
   <span class="m">1</span> <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$exp1</span><span class="s2">&quot;</span> -a <span class="s2">&quot;</span><span class="nv">$exp2</span><span class="s2">&quot;</span> <span class="o">]</span>
</pre></div>

<h3 id="fithen">嵌套的fi/then条件语句<a class="headerlink" href="#fithen" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>使用if/then结构的测试可以嵌套。最终的结果和使用上一节的<span class="o">&amp;&amp;</span>混合比较操作符一样。
<span class="k">if</span> <span class="o">[</span> condition1 <span class="o">]</span>
<span class="k">then</span>
  <span class="k">if</span> <span class="o">[</span> condition2 <span class="o">]</span>
  <span class="k">then</span>
    <span class="k">do</span>-something  <span class="c1"># But only if both &quot;condition1&quot; and &quot;condition2&quot; valid.</span>
   <span class="k">fi</span>  
 <span class="k">fi</span>


<span class="c1">#检测你对测试命令掌握</span>
一个xinitrc系统文件能用来启动一个X服务器。这个文件包含了相当多的if/then测试，就像下面这个文件的一个摘录展示的一样。
<span class="k">if</span> <span class="o">[</span> -f <span class="nv">$HOME</span>/.Xclients <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">exec</span> <span class="nv">$HOME</span>/.Xclients
<span class="k">elif</span> <span class="o">[</span> -f /etc/X11/xinit/Xclients <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">exec</span> /etc/X11/xinit/Xclients
<span class="k">else</span>
     <span class="c1"># 失败后的安全设置。　虽然我们决不该执行到这儿</span>
     <span class="c1"># (我们也在X客户提供可靠保证) 它不能被破坏.</span>
     xclock -geometry 100x100-5+5 <span class="p">&amp;</span>
     xterm -geometry 80x50-50+150 <span class="p">&amp;</span>
     <span class="k">if</span> <span class="o">[</span> -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
             netscape /usr/share/doc/HTML/index.html <span class="p">&amp;</span>
     <span class="k">fi</span>
<span class="k">fi</span>

解释上面摘录的test结构，然后检查整个/etc/X11/xinit/xinitrc文件并分析那儿的所有if/then测试结构。xubuntu在<span class="o">(</span>/etc/xdg/xfce4/xinitrc<span class="o">)</span>路径下
</pre></div>

<h3 id="_19">操作符<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>赋值

变量赋值
<span class="nv">初始化或改变一个变量的值</span>

<span class="o">=</span>
通用的变量赋值操作符，可以用于数值和字符串的赋值
<span class="nv">var</span><span class="o">=</span><span class="m">27</span>
<span class="nv">category</span><span class="o">=</span>minerals  <span class="c1"># &quot;=&quot;字符后面不能加空白字符.</span>

不要把<span class="s2">&quot;=&quot;</span><span class="nv">赋值操作符和</span><span class="o">=</span>测试操作符搞混了。
<span class="c1">#    = 用于测试操作符</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$string1</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="nv">$string2</span><span class="s2">&quot;</span> <span class="o">]</span>
<span class="c1"># if [ &quot;X$string1&quot; = &quot;X$string2&quot; ] 会更安全,</span>
<span class="c1"># 它为了防止其中有一个字符串为空时产生错误信息.</span>
<span class="c1"># (增加的&quot;X&quot;字符可以互相抵消.)</span>
<span class="k">then</span>
   <span class="nb">command</span>
<span class="k">fi</span>

计算操作符

+
加

-
减

*
乘

/
除

**
求幂
<span class="c1"># Bash在版本2.02引入了&quot;**&quot;求幂操作符.</span>
<span class="nb">let</span> <span class="s2">&quot;z=5**3&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;z = </span><span class="nv">$z</span><span class="s2">&quot;</span>   <span class="c1"># z = 125</span>

%
求模（它返回整数整除一个数后的余数）

expr <span class="m">5</span> % <span class="m">3</span>
<span class="m">2</span>

<span class="m">5</span>/3 <span class="o">=</span> <span class="m">1</span> 余 <span class="m">2</span>

This operator finds use in, among other things, generating numbers within a specific range <span class="o">(</span>see Example <span class="m">9</span>-24 and Example <span class="m">9</span>-27<span class="o">)</span> and formatting program output <span class="o">(</span>see Example <span class="m">26</span>-15 and Example A-6<span class="o">)</span>. It can even be used to generate prime numbers, <span class="o">(</span>see Example A-16<span class="o">)</span>. Modulo turns up surprisingly often in various numerical recipes.

<span class="c1">#求最大公约数</span>
<span class="c1">#!/bin/bash</span>
<span class="c1"># gcd.sh: 最大公约数</span>
<span class="c1">#         用Euclid运算法则</span>
<span class="c1">#  两个整数的&quot;最大公约数&quot;</span>
<span class="c1">#+ 是能被这两个整数整除的大最整数.</span>
<span class="c1">#  Euclid运算法则采用逐次除法.</span>
<span class="c1">#  每一次都重新赋值,</span>
<span class="c1">#+ 被除数 &lt;---  除数</span>
<span class="c1">#+ 除数  &lt;---  余数</span>
<span class="c1">#+ 直到 余数 = 0.</span>
<span class="c1">#+ 最后被传递的值中：最大公约数 = 被除数.</span>
<span class="c1">#</span>
<span class="c1">#  关于Euclid运算法则的讨论有一个出色的讨论,</span>
<span class="c1">#  访问Jim Loy的网站, http://www.jimloy.com/number/euclids.htm.</span>
<span class="c1"># ------------------------------------------------------</span>
<span class="c1"># 参数检查</span>
<span class="nv">ARGS</span><span class="o">=</span><span class="m">2</span>
<span class="nv">E_BADARGS</span><span class="o">=</span><span class="m">65</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$#</span> -ne <span class="s2">&quot;</span><span class="nv">$ARGS</span><span class="s2">&quot;</span> <span class="o">]</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Usage: `basename </span><span class="nv">$0</span><span class="s2">` first-number second-number&quot;</span>
  <span class="nb">exit</span> <span class="nv">$E_BADARGS</span>
<span class="k">fi</span>
<span class="c1"># ------------------------------------------------------</span>
gcd <span class="o">()</span>
<span class="o">{</span>
      <span class="nv">dividend</span><span class="o">=</span><span class="nv">$1</span>                    <span class="c1">#  随意赋值.</span>
  <span class="nv">divisor</span><span class="o">=</span><span class="nv">$2</span>                     <span class="c1">#+ 这里在两个参数赋大的还是小的都没有关系.</span>
                                 <span class="c1">#  为什么?</span>
  <span class="nv">remainder</span><span class="o">=</span><span class="m">1</span>                    <span class="c1">#  如果在循环中使用未初始化的变量,</span>
                                 <span class="c1">#+ 在循环中第一个传递值会使它返回一个错误信息</span>
                                 <span class="c1">#</span>
  <span class="k">until</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$remainder</span><span class="s2">&quot;</span> -eq <span class="m">0</span> <span class="o">]</span>
  <span class="k">do</span>
    <span class="nb">let</span> <span class="s2">&quot;remainder = </span><span class="nv">$dividend</span><span class="s2"> % </span><span class="nv">$divisor</span><span class="s2">&quot;</span>
    <span class="nv">dividend</span><span class="o">=</span><span class="nv">$divisor</span>            <span class="c1"># 现在用最小的两个数字来重复.</span>
    <span class="nv">divisor</span><span class="o">=</span><span class="nv">$remainder</span>
  <span class="k">done</span>                           <span class="c1"># Euclid运算法则</span>
<span class="o">}</span>                                <span class="c1"># 最后的$dividend变量值就是最大公约数.</span>
gcd <span class="nv">$1</span> <span class="nv">$2</span>
echo<span class="p">;</span> <span class="nb">echo</span> <span class="s2">&quot;GCD of </span><span class="nv">$1</span><span class="s2"> and </span><span class="nv">$2</span><span class="s2"> = </span><span class="nv">$dividend</span><span class="s2">&quot;</span><span class="p">;</span> <span class="nb">echo</span>
<span class="c1"># 练习:</span>
<span class="c1"># --------</span>
<span class="c1">#  检测命令行参数以确保它们是整数,</span>
<span class="c1">#+ 如果不是整数则给出一个适当的错误信息并退出脚本.</span>
<span class="nb">exit</span> <span class="nv">0</span>
<span class="o">+=</span>
<span class="s2">&quot;加-等(plus-equal)&quot;</span> <span class="o">(</span>把原变量值增加一个常量并重新赋值给变量<span class="o">)</span>

<span class="nb">let</span> <span class="s2">&quot;var += 5&quot;</span>会使变量var值加了5并把值赋给var.

-<span class="o">=</span>
<span class="s2">&quot;(减-等)minus-equal&quot;</span> <span class="o">(</span>把原变量值减少一个常量并重新赋值给变量<span class="o">)</span>

*<span class="o">=</span>
<span class="s2">&quot;(乘-等)times-equal&quot;</span> <span class="o">(</span>把原变量值乘上一个常量并重新赋值给变量<span class="o">)</span>

<span class="nb">let</span> <span class="s2">&quot;var *= 4&quot;</span> 使变量var的值乘上4并把值赋给var.

/<span class="o">=</span>
<span class="s2">&quot;(除-等)slash-equal&quot;</span> <span class="o">(</span>把原变量值除以一个常量并重新赋值给变量<span class="o">)</span>

%<span class="o">=</span>
<span class="s2">&quot;(模-等)mod-equal&quot;</span> <span class="o">(</span>把原变量值除以一个常量整除（译者注：即取模）并重新赋余数的值给变量<span class="o">)</span>

计算操作符常常出现在expr或let命令的表达式中.

例子 <span class="m">8</span>-2. 使用计算操作符

<span class="c1">#!/bin/bash</span>
<span class="c1"># 用10种不同的方法计数到11.</span>

<span class="nv">n</span><span class="o">=</span><span class="m">1</span><span class="p">;</span> <span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

<span class="nb">let</span> <span class="s2">&quot;n = </span><span class="nv">$n</span><span class="s2"> + 1&quot;</span>   <span class="c1"># let &quot;n = n + 1&quot;也可以.</span>
<span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

: <span class="k">$((</span><span class="nv">n</span> <span class="o">=</span> <span class="nv">$n</span> <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
<span class="c1">#  &quot;:&quot;是需要的，</span>
<span class="c1">#+ 否则Bash会尝试把&quot;$((n = $n + 1))&quot;作为命令运行.</span>
<span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

<span class="o">((</span> <span class="nv">n</span> <span class="o">=</span> n + <span class="m">1</span> <span class="o">))</span>
<span class="c1">#  上面是更简单的可行的办法.</span>
<span class="c1">#  多谢David Lombard指出这一点.</span>
<span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

<span class="nv">n</span><span class="o">=</span><span class="k">$((</span><span class="nv">$n</span> <span class="o">+</span> <span class="m">1</span><span class="k">))</span>
<span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

: $<span class="o">[</span> <span class="nv">n</span> <span class="o">=</span> <span class="nv">$n</span> + <span class="m">1</span> <span class="o">]</span>
<span class="c1">#  &quot;:&quot;是需要的，</span>
<span class="c1">#+ 否则Bash会尝试把&quot;$[ n = $n + 1 ]&quot;作为命令运行.</span>
<span class="c1">#  即使&quot;n&quot;被当作字符串来初始化也能工作.</span>
<span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

<span class="nv">n</span><span class="o">=</span>$<span class="o">[</span> <span class="nv">$n</span> + <span class="m">1</span> <span class="o">]</span>
<span class="c1">#  即使&quot;n&quot;被当作字符串来初始化也能工作.</span>
<span class="c1">#* 应避免这种使用这种结构,因为它是被废弃并不可移植的.</span>
<span class="c1">#  多谢Stephane Chazelas.</span>
<span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

<span class="c1"># 现在是C风格的增加操作.</span>
<span class="c1"># 多谢Frank Wang指出这一点.</span>

<span class="nb">let</span> <span class="s2">&quot;n++&quot;</span>          <span class="c1"># let &quot;++n&quot;也可以.</span>
<span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

<span class="o">((</span> n++ <span class="o">))</span>          <span class="c1"># (( ++n )也可以.</span>
<span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

: <span class="k">$((</span> n++ <span class="k">))</span>       <span class="c1"># : $(( ++n ))也可以.</span>
<span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

: $<span class="o">[</span> n++ <span class="o">]</span>         <span class="c1"># : $[ ++n ]]也可以.</span>
<span class="nb">echo</span> -n <span class="s2">&quot;</span><span class="nv">$n</span><span class="s2"> &quot;</span>

<span class="nb">echo</span>

<span class="nb">exit</span> <span class="m">0</span>

Bash中的整数变量实际上是有符号的长整数<span class="o">(</span>32位<span class="o">)</span>，它的范围在-2147483648至2147483647之间。如果有在此范围限制之外的操作将会得到一个错误的结果。
<span class="nv">a</span><span class="o">=</span><span class="m">2147483646</span>
<span class="nb">echo</span> <span class="s2">&quot;a = </span><span class="nv">$a</span><span class="s2">&quot;</span>      <span class="c1"># a = 2147483646</span>
<span class="nb">let</span> <span class="s2">&quot;a+=1&quot;</span>         <span class="c1"># 把变量&quot;a&quot;的值自增一.</span>
<span class="nb">echo</span> <span class="s2">&quot;a = </span><span class="nv">$a</span><span class="s2">&quot;</span>      <span class="c1"># a = 2147483647</span>
<span class="nb">let</span> <span class="s2">&quot;a+=1&quot;</span>         <span class="c1"># 再自增&quot;a&quot;一次,超过这个限制.</span>
<span class="nb">echo</span> <span class="s2">&quot;a = </span><span class="nv">$a</span><span class="s2">&quot;</span>      <span class="c1"># a = -2147483648</span>
                   <span class="c1">#      错误 (溢出)</span>
到2.05b版本为止，Bash支持64位的整数。

Bash不能处理浮点计算。它会把含有小数点的数当成字符串。
<span class="nv">a</span><span class="o">=</span><span class="m">1</span>.5

<span class="nb">let</span> <span class="s2">&quot;b = </span><span class="nv">$a</span><span class="s2"> + 1.3&quot;</span>  <span class="c1"># 错误</span>
<span class="c1"># t2.sh: let: b = 1.5 + 1.3: syntax error in expression (error token is 5 + 1.3&quot;) 意为表达式错误(错误的符号&quot;.5 + 1.3&quot;)</span>

<span class="nb">echo</span> <span class="s2">&quot;b = </span><span class="nv">$b</span><span class="s2">&quot;</span>       <span class="c1"># b=1</span>
在脚本中用bc需要浮点计算或数学库函数的支持。

位操作符. 位操作符很少在脚本中使用。他们主要用于操作和测试从端口或sockets中读到的数据。“位运算”更多地用于编译型的语言，比如说C和C++，它们运行起来快地像飞。

位操作符

<span class="s">&lt;&lt;</span>
<span class="s">位左移（每移一位相当乘以2）</span>

<span class="s">: &lt;&lt;comment</span>

<span class="s">&lt;&lt;=</span>
<span class="s">&quot;位左移</span>赋值<span class="s2">&quot;</span>

<span class="s2">comment</span>

<span class="s2">let &quot;</span>var &lt;&lt;<span class="o">=</span> <span class="m">2</span><span class="s2">&quot; 结果使var的二进制值左移了二位（相当于乘以4）</span>

<span class="s2">&gt;&gt;</span>
<span class="s2">位右移（每移一位相当除以2）</span>

<span class="s2">: &lt;&lt;comment</span>

<span class="s2">&gt;&gt;=</span>
<span class="s2">&quot;</span>位右移赋值<span class="s2">&quot;（和&lt;&lt;=相反）</span>

<span class="s2">comment</span>

<span class="s2">&amp;</span>
<span class="s2">位与</span>

<span class="s2">&amp;=</span>
<span class="s2">&quot;</span>位于赋值<span class="s2">&quot;</span>

<span class="s2">|</span>
<span class="s2">位或</span>

<span class="s2">|=</span>
<span class="s2">&quot;</span>位或赋值<span class="s2">&quot;</span>

<span class="s2">~</span>
<span class="s2">位反</span>

<span class="s2">!</span>
<span class="s2">位非</span>

<span class="s2">^</span>
<span class="s2">位或</span>

<span class="s2">^=</span>
<span class="s2">&quot;</span>位或赋值<span class="s2">&quot;</span>

<span class="s2">逻辑操作符</span>

<span class="s2">&amp;&amp;</span>
<span class="s2">逻辑与</span>

<span class="s2">if [ </span><span class="nv">$condition1</span><span class="s2"> ] &amp;&amp; [ </span><span class="nv">$condition2</span><span class="s2"> ]</span>
<span class="s2"># 等同于:  if [ </span><span class="nv">$condition1</span><span class="s2"> -a </span><span class="nv">$condition2</span><span class="s2"> ]</span>
<span class="s2"># 如果condition1和condition2都为真则返回真...</span>

<span class="s2">if [[ </span><span class="nv">$condition1</span><span class="s2"> &amp;&amp; </span><span class="nv">$condition2</span><span class="s2"> ]]    # Also works.</span>
<span class="s2"># 注意&amp;&amp;操作不能在[ ... ]结构中使用.</span>

<span class="s2">依据上下文，&amp;&amp;也可以在与列表(and list)连接命令中。</span>

<span class="s2">||</span>
<span class="s2">逻辑或</span>

<span class="s2">if [ </span><span class="nv">$condition1</span><span class="s2"> ] || [ </span><span class="nv">$condition2</span><span class="s2"> ]</span>
<span class="s2"># 等同于:  if [ </span><span class="nv">$condition1</span><span class="s2"> -o </span><span class="nv">$condition2</span><span class="s2"> ]</span>
<span class="s2"># 如果condition1和condition2有一个为真则返回真...</span>
<span class="s2">if [[ </span><span class="nv">$condition1</span><span class="s2"> || </span><span class="nv">$condition2</span><span class="s2"> ]]    # Also works.</span>
<span class="s2"># 注意||操作不能在[ ... ]结构中使用.</span>

<span class="s2">Bash测试由逻辑操作符连接起来的每一个表达式的退出状态。</span>


<span class="s2">#使用&amp;&amp;和||进行混合条件测试</span>
<span class="s2">#!/bin/bash</span>

<span class="s2">a=24</span>
<span class="s2">b=47</span>

<span class="s2">if [ &quot;</span><span class="nv">$a</span><span class="s2">&quot; -eq 24 ] &amp;&amp; [ &quot;</span><span class="nv">$b</span><span class="s2">&quot; -eq 47 ]</span>
<span class="s2">then</span>
<span class="s2">  echo &quot;</span>Test <span class="c1">#1 succeeds.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;Test #1 fails.&quot;</span>
<span class="k">fi</span>

<span class="c1"># 错误:   if [ &quot;$a&quot; -eq 24 &amp;&amp; &quot;$b&quot; -eq 47 ]</span>
<span class="c1">#+         这会尝试执行&#39; [ &quot;$a&quot; -eq 24 &#39;</span>
<span class="c1">#+         然后会因没找到匹配的&#39;]&#39;而失败.</span>
<span class="c1">#</span>
<span class="c1">#  注意:  if [[ $a -eq 24 &amp;&amp; $b -eq 24 ]]也可以.</span>
<span class="c1">#  双方括号的if-test比</span>
<span class="c1">#+ 单方括号的结构更灵活</span>
<span class="c1">#    (第17行和第6行的&quot;&amp;&amp;&quot;有不同的意思.)</span>
<span class="c1">#    多谢Stephane Chazelas指出这一点.</span>


<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> -eq <span class="m">98</span> <span class="o">]</span> <span class="o">||</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> -eq <span class="m">47</span> <span class="o">]</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Test #2 succeeds.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;Test #2 fails.&quot;</span>
<span class="k">fi</span>


<span class="c1">#  -a和-o选项提供</span>
<span class="c1">#+ 混合条件测试另一个选择.</span>
<span class="c1">#  多谢Patrick Callahan指出这一点.</span>


<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> -eq <span class="m">24</span> -a <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> -eq <span class="m">47</span> <span class="o">]</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Test #3 succeeds.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;Test #3 fails.&quot;</span>
<span class="k">fi</span>


<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> -eq <span class="m">98</span> -o <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> -eq <span class="m">47</span> <span class="o">]</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Test #4 succeeds.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;Test #4 fails.&quot;</span>
<span class="k">fi</span>


<span class="nv">a</span><span class="o">=</span>rhino
<span class="nv">b</span><span class="o">=</span>crocodile
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$a</span><span class="s2">&quot;</span> <span class="o">=</span> rhino <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$b</span><span class="s2">&quot;</span> <span class="o">=</span> crocodile <span class="o">]</span>
<span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Test #5 succeeds.&quot;</span>
<span class="k">else</span>
  <span class="nb">echo</span> <span class="s2">&quot;Test #5 fails.&quot;</span>
<span class="k">fi</span>

<span class="nb">exit</span> <span class="m">0</span>
在算术计算的环境中，<span class="o">&amp;&amp;</span>和<span class="o">||</span>操作符也可以使用。

<span class="nb">echo</span> <span class="k">$((</span> <span class="m">1</span> <span class="o">&amp;&amp;</span> <span class="m">2</span> <span class="k">))</span> <span class="k">$((</span><span class="m">3</span> <span class="o">&amp;&amp;</span> <span class="m">0</span><span class="k">))</span> <span class="k">$((</span><span class="m">4</span> <span class="o">||</span> <span class="m">0</span><span class="k">))</span> <span class="k">$((</span><span class="m">0</span> <span class="o">||</span> <span class="m">0</span><span class="k">))</span>
<span class="m">1</span> <span class="m">0</span> <span class="m">1</span> <span class="m">0</span>

杂合的其他操作符

,   逗号操作符

逗号操作符连接两个或更多的算术操作。所有的操作都被求值<span class="o">(</span>可能会有副作用<span class="o">)</span>，但只返回最后一个操作的结构
<span class="nb">let</span> <span class="s2">&quot;t1 = ((5 + 3, 7 - 1, 15 - 4))&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;t1 = </span><span class="nv">$t1</span><span class="s2">&quot;</span>               <span class="c1"># t1 = 11</span>

<span class="nb">let</span> <span class="s2">&quot;t2 = ((a = 9, 15 / 3))&quot;</span>  <span class="c1"># 初始化&quot;a&quot;并求&quot;t2&quot;的值.</span>
<span class="nb">echo</span> <span class="s2">&quot;t2 = </span><span class="nv">$t2</span><span class="s2">    a = </span><span class="nv">$a</span><span class="s2">&quot;</span>     <span class="c1"># t2 = 5    a = 9</span>

逗号操作符主要用在for 循环里.
</pre></div>

<h3 id="_20">数字常量<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span>除非一个数字有特别的前缀或符号，否则shell脚本把它当成十进制的数。一个前缀为0的数字是八进制数。一个前缀为0x的数字是十六进制数。一个数用内嵌的#来求值则看成BASE#NUMBER<span class="o">(</span>有范围和符号限制<span class="o">)(</span>译者注：BASE#NUMBER即：基数#数值，参考下面的例子<span class="o">)</span>

<span class="c1">#数字常量的表示法</span>
<span class="c1">#!/bin/bash</span>
<span class="c1"># numbers.sh: 不同基数的数字表示法.</span>

<span class="c1"># 十进制数: 它是默认的</span>
<span class="nb">let</span> <span class="s2">&quot;dec = 32&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;decimal number = </span><span class="nv">$dec</span><span class="s2">&quot;</span>             <span class="c1"># 32</span>
<span class="c1"># 这儿没有什么特别的.</span>


<span class="c1"># 八进制数: 以&#39;0&#39;(零)为前缀</span>
<span class="nb">let</span> <span class="s2">&quot;oct = 032&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;octal number = </span><span class="nv">$oct</span><span class="s2">&quot;</span>               <span class="c1"># 26</span>
<span class="c1"># 结果表示为十进制.</span>
<span class="c1"># --------- ------ -- -------</span>

<span class="c1"># 十六进制: 以&#39;0x&#39;或&#39;0X&#39;为前缀</span>
<span class="nb">let</span> <span class="s2">&quot;hex = 0x32&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;hexadecimal number = </span><span class="nv">$hex</span><span class="s2">&quot;</span>         <span class="c1"># 50</span>
<span class="c1"># 以十进制的形式表示.</span>

<span class="c1"># 其他的进制的表示形式: BASE#NUMBER</span>
<span class="c1"># BASE值在2和64之间.</span>
<span class="c1"># NUMBER必须使用在BASE范围内的符号,看下面的示例.</span>


<span class="nb">let</span> <span class="s2">&quot;bin = 2#111100111001101&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;binary number = </span><span class="nv">$bin</span><span class="s2">&quot;</span>              <span class="c1"># 31181</span>

<span class="nb">let</span> <span class="s2">&quot;b32 = 32#77&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;base-32 number = </span><span class="nv">$b32</span><span class="s2">&quot;</span>             <span class="c1"># 231</span>

<span class="nb">let</span> <span class="s2">&quot;b64 = 64#@_&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;base-64 number = </span><span class="nv">$b64</span><span class="s2">&quot;</span>             <span class="c1"># 4031</span>
<span class="c1"># 这个符号只能工作在ASCII码值为2-64的范围限制.</span>
<span class="c1"># 10个数字+26个小写字母+26个大写字母+ @ + _</span>


<span class="nb">echo</span>

<span class="nb">echo</span> <span class="k">$((</span><span class="m">36#</span>zz<span class="k">))</span> <span class="k">$((</span><span class="m">2#10101010</span><span class="k">))</span> <span class="k">$((</span><span class="m">16#</span>AF16<span class="k">))</span> <span class="k">$((</span><span class="m">53#1</span>aA<span class="k">))</span>
<span class="c1"># 1295 170 44822 3375</span>


<span class="c1">#  重要提示:</span>
<span class="c1">#  --------------</span>
<span class="c1">#  使用一个超出给定进制的数字将会引起一个错误信息。</span>
<span class="c1">#+ gives an error message.</span>

<span class="nb">let</span> <span class="s2">&quot;bad_oct = 081&quot;</span>
<span class="c1"># ((部分的) 错误信息输出:</span>
<span class="c1">#  bad_oct = 081: value too great for base (error token is &quot;081&quot;)</span>
<span class="c1"># 八进制数字只能使用数字0-7.</span>
</pre></div>

<h3 id="readechoprintf">read内置命令是echo和printf命令的对应命令<a class="headerlink" href="#readechoprintf" title="Permanent link">&para;</a></h3>
<p>读取内置的选项</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">-a ANAME</td>
<td align="center">The words are assigned to sequential indexes of the array variable ANAME, starting at 0 All elements are removed from ANAME before the assignment Other NAME arguments are ignored</td>
</tr>
<tr>
<td align="center">-d DELIM</td>
<td align="center">The first character of DELIM is used to terminate the input line, rather than newline</td>
</tr>
<tr>
<td align="center">-e</td>
<td align="center">readline is used to obtain the line</td>
</tr>
<tr>
<td align="center">-n NCHARS</td>
<td align="center">read returns after reading NCHARS characters rather than waiting for a complete line of input</td>
</tr>
<tr>
<td align="center">-p PROMPT</td>
<td align="center">Display PROMPT, without a trailing newline, before attempting to read any input The prompt is displayed only if input is coming from a terminal</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">If this option is given, backslash does not act as an escape character The backslash is considered to be part of the line In particular, a backslash-newline pair may not be used as a line continuation</td>
</tr>
<tr>
<td align="center">-s</td>
<td align="center">Silent mode If input is coming from a terminal, characters are not echoed</td>
</tr>
<tr>
<td align="center">-t TIMEOUT</td>
<td align="center">Cause read to time out and return failure if a complete line of input is not read within TIMEOUT seconds This option has no effect if read is not reading input from the terminal or from a pipe</td>
</tr>
<tr>
<td align="center">-u FD</td>
<td align="center">Read input from file descriptor FD</td>
</tr>
</tbody>
</table>
<h3 id="sedawkgrep">sed&amp;awk&amp;grep<a class="headerlink" href="#sedawkgrep" title="Permanent link">&para;</a></h3>
<h2 id="_21">文本间隔：<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h2>
<p># 在每一行后面增加一空行
 sed G</p>
<p># 将原来的所有空行删除并在每一行后面增加一空行。
 # 这样在输出的文本中每一行后面将有且只有一空行。
 sed '/^$/d;G'</p>
<p># 在每一行后面增加两行空行
 sed 'G;G'</p>
<p># 将第一个脚本所产生的所有空行删除（即删除所有偶数行）
 sed 'n;d'</p>
<p># 在匹配式样“regex”的行之前插入一空行
 sed '/regex/{x;p;x;}'</p>
<p># 在匹配式样“regex”的行之后插入一空行
 sed '/regex/G'</p>
<p># 在匹配式样“regex”的行之前和之后各插入一空行
 sed '/regex/{x;p;x;G;}'</p>
<h2 id="_22">编号：<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h2>
<p># 为文件中的每一行进行编号（简单的左对齐方式）。这里使用了“制表符”
 # （tab，见本文末尾关于'\t'的用法的描述）而不是空格来对齐边缘。
 sed = filename | sed 'N;s/\n/\t/'</p>
<p># 对文件中的所有行编号（行号在左，文字右端对齐）。
 sed = filename | sed 'N; s/^/     /; s/ *<span><span class="MathJax_Preview">.\{6,\}</span><script type="math/tex">.\{6,\}</script></span>\n/\1  /'</p>
<p># 对文件中的所有行编号，但只显示非空白行的行号。
 sed '/./=' filename | sed '/./N; s/\n/ /'</p>
<p># 计算行数 （模拟 "wc -l"）
 sed -n '$='</p>
<h2 id="_23">文本转换和替代：<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h2>
<p># Unix环境：转换DOS的新行符（CR/LF）为Unix格式。
 sed 's/.<span><span class="MathJax_Preview">//'                     # 假设所有行以CR/LF结束
 sed 's/^M</span><script type="math/tex">//'                     # 假设所有行以CR/LF结束
 sed 's/^M</script></span>//'                    # 在bash/tcsh中，将按Ctrl-M改为按Ctrl-V
 sed 's/\x0D$//'                  # ssed、gsed 3.02.80，及更高版本</p>
<p># Unix环境：转换Unix的新行符（LF）为DOS格式。
 sed "s/<span><span class="MathJax_Preview">/<code class="codehilite">echo -e \\\r</code>/"        # 在ksh下所使用的命令
 sed 's//"        # 在ksh下所使用的命令
 sed 's/</span><script type="math/tex">/<code class="codehilite">echo -e \\\r</code>/"        # 在ksh下所使用的命令
 sed 's//"        # 在ksh下所使用的命令
 sed 's/</script></span>'"/<code class="codehilite">echo \\\r</code>/"         # 在bash下所使用的命令
 sed "s/<span><span class="MathJax_Preview">/<code class="codehilite">echo \\\r</code>/"           # 在zsh下所使用的命令
 sed 's//"           # 在zsh下所使用的命令
 sed 's/</span><script type="math/tex">/<code class="codehilite">echo \\\r</code>/"           # 在zsh下所使用的命令
 sed 's//"           # 在zsh下所使用的命令
 sed 's/</script></span>/\r/'                    # gsed 3.02.80 及更高版本</p>
<p># DOS环境：转换Unix新行符（LF）为DOS格式。
 sed "s/$//"                      # 方法 1
 sed -n p                         # 方法 2</p>
<p># DOS环境：转换DOS新行符（CR/LF）为Unix格式。
 # 下面的脚本只对UnxUtils sed 4.0.7 及更高版本有效。要识别UnxUtils版本的
 #  sed可以通过其特有的“--text”选项。你可以使用帮助选项（“--help”）看
 # 其中有无一个“--text”项以此来判断所使用的是否是UnxUtils版本。其它DOS
 # 版本的的sed则无法进行这一转换。但可以用“tr”来实现这一转换。
 sed "s/\r//" infile &gt;outfile     # UnxUtils sed v4.0.7 或更高版本
 tr -d \r <infile >outfile        # GNU tr 1.22 或更高版本</p>
<p># 将每一行前导的“空白字符”（空格，制表符）删除
 # 使之左对齐
 sed 's/^[ \t]*//'                # 见本文末尾关于'\t'用法的描述</p>
<p># 将每一行拖尾的“空白字符”（空格，制表符）删除
 sed 's/[ \t]*$//'                # 见本文末尾关于'\t'用法的描述</p>
<p># 将每一行中的前导和拖尾的空白字符删除
 sed 's/^[ \t]<em>//;s/[ \t]</em>$//'</p>
<p># 在每一行开头处插入5个空格（使全文向右移动5个字符的位置）
 sed 's/^/     /'</p>
<p># 以79个字符为宽度，将所有文本右对齐
 sed -e :a -e 's/^.{1,78}$/ &amp;/;ta'  # 78个字符外加最后的一个空格</p>
<p># 以79个字符为宽度，使所有文本居中。在方法1中，为了让文本居中每一行的前
 # 头和后头都填充了空格。 在方法2中，在居中文本的过程中只在文本的前面填充
 # 空格，并且最终这些空格将有一半会被删除。此外每一行的后头并未填充空格。
 sed  -e :a -e 's/^.{1,77}<span><span class="MathJax_Preview">/ &amp; /;ta'                     # 方法1
 sed  -e :a -e 's/^.\{1,77\}</span><script type="math/tex">/ & /;ta'                     # 方法1
 sed  -e :a -e 's/^.\{1,77\}</script></span>/ &amp;/;ta' -e 's/<span><span class="MathJax_Preview"> *</span><script type="math/tex"> *</script></span>\1/\1/'  # 方法2</p>
<p># 在每一行中查找字串“foo”，并将找到的“foo”替换为“bar”
 sed 's/foo/bar/'                 # 只替换每一行中的第一个“foo”字串
 sed 's/foo/bar/4'                # 只替换每一行中的第四个“foo”字串
 sed 's/foo/bar/g'                # 将每一行中的所有“foo”都换成“bar”
 sed 's/<span><span class="MathJax_Preview">.*</span><script type="math/tex">.*</script></span>foo<span><span class="MathJax_Preview">.*foo</span><script type="math/tex">.*foo</script></span>/\1bar\2/' # 替换倒数第二个“foo”
 sed 's/<span><span class="MathJax_Preview">.*</span><script type="math/tex">.*</script></span>foo/\1bar/'            # 替换最后一个“foo”</p>
<p># 只在行中出现字串“baz”的情况下将“foo”替换成“bar”
 sed '/baz/s/foo/bar/g'</p>
<p># 将“foo”替换成“bar”，并且只在行中未出现字串“baz”的情况下替换
 sed '/baz/!s/foo/bar/g'</p>
<p># 不管是“scarlet”“ruby”还是“puce”，一律换成“red”
 sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'  #对多数的sed都有效
 gsed 's/scarlet|ruby|puce/red/g'               # 只对GNU sed有效</p>
<p># 倒置所有行，第一行成为最后一行，依次类推（模拟“tac”）。
 # 由于某些原因，使用下面命令时HHsed v1.5会将文件中的空行删除
 sed '1!G;h;<span><span class="MathJax_Preview">!d'               # 方法1
 sed -n '1!G;h;</span><script type="math/tex">!d'               # 方法1
 sed -n '1!G;h;</script></span>p'             # 方法2</p>
<p># 将行中的字符逆序排列，第一个字成为最后一字，……（模拟“rev”）
 sed '/\n/!G;s/<span><span class="MathJax_Preview">.</span><script type="math/tex">.</script></span><span><span class="MathJax_Preview">.*\n</span><script type="math/tex">.*\n</script></span>/&amp;\2\1/;//D;s/.//'</p>
<p># 将每两行连接成一行（类似“paste”）
 sed '$!N;s/\n/ /'</p>
<p># 如果当前行以反斜杠“\”结束，则将下一行并到当前行末尾
 # 并去掉原来行尾的反斜杠
 sed -e :a -e '/\$/N; s/\\n//; ta'</p>
<p># 如果当前行以等号开头，将当前行并到上一行末尾
 # 并以单个空格代替原来行头的“=”
 sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'</p>
<p># 为数字字串增加逗号分隔符号，将“1234567”改为“1,234,567”
 gsed ':a;s/\B[0-9]{3}>/,&amp;/;ta'                     # GNU sed
 sed -e :a -e 's/<span><span class="MathJax_Preview">.*[0-9]</span><script type="math/tex">.*[0-9]</script></span><span><span class="MathJax_Preview">[0-9]\{3\}</span><script type="math/tex">[0-9]\{3\}</script></span>/\1,\2/;ta'  # 其他sed</p>
<p># 为带有小数点和负号的数值增加逗号分隔符（GNU sed）
 gsed -r ':a;s/(<sup>|[</sup>0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta'</p>
<p># 在每5行后增加一空白行 （在第5，10，15，20，等行后增加一空白行）
 gsed '0~5G'                      # 只对GNU sed有效
 sed 'n;n;n;n;G;'                 # 其他sed</p>
<h2 id="_24">选择性地显示特定行：<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h2>
<p># 显示文件中的前10行 （模拟“head”的行为）
 sed 10q</p>
<p># 显示文件中的第一行 （模拟“head -1”命令）
 sed q</p>
<p># 显示文件中的最后10行 （模拟“tail”）
 sed -e :a -e '<span><span class="MathJax_Preview">q;N;11,</span><script type="math/tex">q;N;11,</script></span>D;ba'</p>
<p># 显示文件中的最后2行（模拟“tail -2”命令）
 sed '<span><span class="MathJax_Preview">!N;</span><script type="math/tex">!N;</script></span>!D'</p>
<p># 显示文件中的最后一行（模拟“tail -1”）
 sed '<span><span class="MathJax_Preview">!d'                        # 方法1
 sed -n '</span><script type="math/tex">!d'                        # 方法1
 sed -n '</script></span>p'                      # 方法2</p>
<p># 显示文件中的倒数第二行
 sed -e '<span><span class="MathJax_Preview">!{h;d;}' -e x              # 当文件中只有一行时，输入空行
 sed -e '1{</span><script type="math/tex">!{h;d;}' -e x              # 当文件中只有一行时，输入空行
 sed -e '1{</script></span>q;}' -e '<span><span class="MathJax_Preview">!{h;d;}' -e x  # 当文件中只有一行时，显示该行
 sed -e '1{</span><script type="math/tex">!{h;d;}' -e x  # 当文件中只有一行时，显示该行
 sed -e '1{</script></span>d;}' -e '$!{h;d;}' -e x  # 当文件中只有一行时，不输出</p>
<p># 只显示匹配正则表达式的行（模拟“grep”）
 sed -n '/regexp/p'               # 方法1
 sed '/regexp/!d'                 # 方法2</p>
<p># 只显示“不”匹配正则表达式的行（模拟“grep -v”）
 sed -n '/regexp/!p'              # 方法1，与前面的命令相对应
 sed '/regexp/d'                  # 方法2，类似的语法</p>
<p># 查找“regexp”并将匹配行的上一行显示出来，但并不显示匹配行
 sed -n '/regexp/{g;1!p;};h'</p>
<p># 查找“regexp”并将匹配行的下一行显示出来，但并不显示匹配行
 sed -n '/regexp/{n;p;}'</p>
<p># 显示包含“regexp”的行及其前后行，并在第一行之前加上“regexp”所
 # 在行的行号 （类似“grep -A1 -B1”）
 sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h</p>
<p># 显示包含“AAA”、“BBB”或“CCC”的行（任意次序）
 sed '/AAA/!d; /BBB/!d; /CCC/!d'  # 字串的次序不影响结果</p>
<p># 显示包含“AAA”、“BBB”和“CCC”的行（固定次序）
 sed '/AAA.*BBB.*CCC/!d'</p>
<p># 显示包含“AAA”“BBB”或“CCC”的行 （模拟“egrep”）
 sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d    # 多数sed
 gsed '/AAA|BBB|CCC/!d'                        # 对GNU sed有效</p>
<p># 显示包含“AAA”的段落 （段落间以空行分隔）
 # HHsed v1.5 必须在“x;”后加入“G;”，接下来的3个脚本都是这样
 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;'</p>
<p># 显示包含“AAA”“BBB”和“CCC”三个字串的段落 （任意次序）
 sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d'</p>
<p># 显示包含“AAA”、“BBB”、“CCC”三者中任一字串的段落 （任意次序）
 sed -e '/./{H;<span><span class="MathJax_Preview">!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
 gsed '/./{H;</span><script type="math/tex">!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
 gsed '/./{H;</script></span>!d;};x;/AAA|BBB|CCC/b;d'         # 只对GNU sed有效</p>
<p># 显示包含65个或以上字符的行
 sed -n '/^.{65}/p'</p>
<p># 显示包含65个以下字符的行
 sed -n '/^.{65}/!p'            # 方法1，与上面的脚本相对应
 sed '/^.{65}/d'                # 方法2，更简便一点的方法</p>
<p># 显示部分文本——从包含正则表达式的行开始到最后一行结束
 sed -n '/regexp/,$p'</p>
<p># 显示部分文本——指定行号范围（从第8至第12行，含8和12行）
 sed -n '8,12p'                   # 方法1
 sed '8,12!d'                     # 方法2</p>
<p># 显示第52行
 sed -n '52p'                     # 方法1
 sed '52!d'                       # 方法2
 sed '52q;d'                      # 方法3, 处理大文件时更有效率</p>
<p># 从第3行开始，每7行显示一次  <br />
 gsed -n '3~7p'                   # 只对GNU sed有效
 sed -n '3,${p;n;n;n;n;n;n;}'     # 其他sed</p>
<p># 显示两个正则表达式之间的文本（包含）
 sed -n '/Iowa/,/Montana/p'       # 区分大小写方式</p>
<h2 id="_25">选择性地删除特定行：<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h2>
<p># 显示通篇文档，除了两个正则表达式之间的内容
 sed '/Iowa/,/Montana/d'</p>
<p># 删除文件中相邻的重复行（模拟“uniq”）
 # 只保留重复行中的第一行，其他行删除
 sed '<span><span class="MathJax_Preview">!N; /^\(.*\)\n\1</span><script type="math/tex">!N; /^\(.*\)\n\1</script></span>/!P; D'</p>
<p># 删除文件中的重复行，不管有无相邻。注意hold space所能支持的缓存
 # 大小，或者使用GNU sed。
 sed -n 'G; s/\n/&amp;&amp;/; /^<span><span class="MathJax_Preview">[ -~]*\n</span><script type="math/tex">[ -~]*\n</script></span>.*\n\1/d; s/\n//; h; P'</p>
<p># 删除除重复行外的所有行（模拟“uniq -d”）
 sed '<span><span class="MathJax_Preview">!N; s/^\(.*\)\n\1</span><script type="math/tex">!N; s/^\(.*\)\n\1</script></span>/\1/; t; D'</p>
<p># 删除文件中开头的10行
 sed '1,10d'</p>
<p># 删除文件中的最后一行
 sed '$d'</p>
<p># 删除文件中的最后两行
 sed 'N;<span><span class="MathJax_Preview">!P;</span><script type="math/tex">!P;</script></span>!D;$d'</p>
<p># 删除文件中的最后10行
 sed -e :a -e '$d;N;2,10ba' -e 'P;D'   # 方法1
 sed -n -e :a -e '1,10!{P;N;D;};N;ba'  # 方法2</p>
<p># 删除8的倍数行
 gsed '0~8d'                           # 只对GNU sed有效
 sed 'n;n;n;n;n;n;n;d;'                # 其他sed</p>
<p># 删除匹配式样的行
 sed '/pattern/d'                      # 删除含pattern的行。当然pattern
                                       # 可以换成任何有效的正则表达式</p>
<p># 删除文件中的所有空行（与“grep '.' ”效果相同）
 sed '/^$/d'                           # 方法1
 sed '/./!d'                           # 方法2</p>
<p># 只保留多个相邻空行的第一行。并且删除文件顶部和尾部的空行。
 # （模拟“cat -s”）
 sed '/./,/^<span><span class="MathJax_Preview">/!d'        #方法1，删除文件顶部的空行，允许尾部保留一空行
 sed '/^</span><script type="math/tex">/!d'        #方法1，删除文件顶部的空行，允许尾部保留一空行
 sed '/^</script></span>/N;/\n$/D'      #方法2，允许顶部保留一空行，尾部不留空行</p>
<p># 只保留多个相邻空行的前两行。
 sed '/^<span><span class="MathJax_Preview">/N;/\n</span><script type="math/tex">/N;/\n</script></span>/N;//D'</p>
<p># 删除文件顶部的所有空行
 sed '/./,$!d'</p>
<p># 删除文件尾部的所有空行
 sed -e :a -e '/^\n*<span><span class="MathJax_Preview">/{</span><script type="math/tex">/{</script></span>d;N;ba' -e '}'  # 对所有sed有效
 sed -e :a -e '/^\n*<span><span class="MathJax_Preview">/N;/\n</span><script type="math/tex">/N;/\n</script></span>/ba'        # 同上，但只对 gsed 3.02.*有效</p>
<p># 删除每个段落的最后一行
 sed -n '/^$/{p;h;};/./{x;/./p;}'</p>
<h2 id="_26">特殊应用：<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h2>
<p># 移除手册页（man page）中的nroff标记。在Unix System V或bash shell下使
 # 用'echo'命令时可能需要加上 -e 选项。
 sed "s/.<code class="codehilite">echo \\\b</code>//g"    # 外层的双括号是必须的（Unix环境）
 sed 's/.^H//g'             # 在bash或tcsh中, 按 Ctrl-V 再按 Ctrl-H
 sed 's/.\x08//g'           # sed 1.5，GNU sed，ssed所使用的十六进制的表示方法</p>
<p># 提取新闻组或 e-mail 的邮件头
 sed '/^$/q'                # 删除第一行空行后的所有内容</p>
<p># 提取新闻组或 e-mail 的正文部分
 sed '1,/^$/d'              # 删除第一行空行之前的所有内容</p>
<p># 从邮件头提取“Subject”（标题栏字段），并移除开头的“Subject:”字样
 sed '/^Subject: */!d; s///;q'</p>
<p># 从邮件头获得回复地址
 sed '/^Reply-To:/q; /^From:/h; /./d;g;q'</p>
<p># 获取邮件地址。在上一个脚本所产生的那一行邮件头的基础上进一步的将非电邮
 # 地址的部分剃除。（见上一脚本）
 sed 's/ <em>(.</em>)//; s/&gt;.<em>//; s/.</em>[:&lt;] *//'</p>
<p># 在每一行开头加上一个尖括号和空格（引用信息）
 sed 's/^/&gt; /'</p>
<p># 将每一行开头处的尖括号和空格删除（解除引用）
 sed 's/^&gt; //'</p>
<p># 移除大部分的HTML标签（包括跨行标签）
 sed -e :a -e 's/&lt;[^&gt;]*&gt;//g;/&lt;/N;//ba'</p>
<p># 将分成多卷的uuencode文件解码。移除文件头信息，只保留uuencode编码部分。
 # 文件必须以特定顺序传给sed。下面第一种版本的脚本可以直接在命令行下输入；
 # 第二种版本则可以放入一个带执行权限的shell脚本中。（由Rahul Dhesi的一
 # 个脚本修改而来。）
 sed '/<sup>end/,/</sup>begin/d' file1 file2 ... fileX | uudecode   # vers. 1
 sed '/<sup>end/,/</sup>begin/d' "$@" | uudecode                    # vers. 2</p>
<p># 将文件中的段落以字母顺序排序。段落间以（一行或多行）空行分隔。GNU sed使用
 # 字元“\v”来表示垂直制表符，这里用它来作为换行符的占位符——当然你也可以
 # 用其他未在文件中使用的字符来代替它。
 sed '/./{H;d;};x;s/\n/={NL}=/g' file | sort | sed '1s/={NL}=//;s/={NL}=/\n/g'
 gsed '/./{H;d};x;y/\n/\v/' file | sort | sed '1s/\v//;y/\v/\n/'</p>
<p># 分别压缩每个.TXT文件，压缩后删除原来的文件并将压缩后的.ZIP文件
 # 命名为与原来相同的名字（只是扩展名不同）。（DOS环境：“dir /b”
 # 显示不带路径的文件名）。
 echo @echo off &gt;zipup.bat
 dir /b *.txt | sed "s/^<span><span class="MathJax_Preview">.*</span><script type="math/tex">.*</script></span>.TXT/pkzip -mo \1 \1.TXT/" &gt;&gt;zipup.bat</p>
<p>使用SED：Sed接受一个或多个编辑命令，并且每读入一行后就依次应用这些命令。
当读入第一行输入后，sed对其应用所有的命令，然后将结果输出。接着再读入第二
行输入，对其应用所有的命令……并重复这个过程。上一个例子中sed由标准输入设
备（即命令解释器，通常是以管道输入的形式）获得输入。在命令行给出一个或多
个文件名作为参数时，这些文件取代标准输入设备成为sed的输入。sed的输出将被
送到标准输出（显示器）。因此：</p>
<p>cat filename | sed '10q'         # 使用管道输入
 sed '10q' filename               # 同样效果，但不使用管道输入
 sed '10q' filename &gt; newfile     # 将输出转移（重定向）到磁盘上</p>
<p>要了解sed命令的使用说明，包括如何通过脚本文件（而非从命令行）来使用这些命
令，请参阅《sed &amp; awk》第二版，作者Dale Dougherty和Arnold Robbins
（O'Reilly，1997；<a href="http://www.ora.com">http://www.ora.com</a>），《UNIX Text Processing》，作者
Dale Dougherty和Tim O'Reilly（Hayden Books，1987）或者是Mike Arst写的教
程——压缩包的名称是“U-SEDIT2.ZIP”（在许多站点上都找得到）。要发掘sed
的潜力，则必须对“正则表达式”有足够的理解。正则表达式的资料可以看
《Mastering Regular Expressions》作者Jeffrey Friedl（O'reilly 1997）。
Unix系统所提供的手册页（“man”）也会有所帮助（试一下这些命令
“man sed”、“man regexp”，或者看“man ed”中关于正则表达式的部分），但
手册提供的信息比较“抽象”——这也是它一直为人所诟病的。不过，它本来就不
是用来教初学者如何使用sed或正则表达式的教材，而只是为那些熟悉这些工具的人
提供的一些文本参考。</p>
<p>括号语法：前面的例子对sed命令基本上都使用单引号（'...'）而非双引号
（"..."）这是因为sed通常是在Unix平台上使用。单引号下，Unix的shell（命令
解释器）不会对美元符（$）和后引号（<code class="codehilite">...</code>）进行解释和执行。而在双引号下
美元符会被展开为变量或参数的值，后引号中的命令被执行并以输出的结果代替
后引号中的内容。而在“csh”及其衍生的shell中使用感叹号（!）时需要在其前
面加上转义用的反斜杠（就像这样：!）以保证上面所使用的例子能正常运行
（包括使用单引号的情况下）。DOS版本的Sed则一律使用双引号（"..."）而不是
引号来圈起命令。</p>
<p>'\t'的用法：为了使本文保持行文简洁，我们在脚本中使用'\t'来表示一个制表
符。但是现在大部分版本的sed还不能识别'\t'的简写方式，因此当在命令行中为
脚本输入制表符时，你应该直接按TAB键来输入制表符而不是输入'\t'。下列的工
具软件都支持'\t'做为一个正则表达式的字元来表示制表符：awk、perl、HHsed、
sedmod以及GNU sed v3.02.80。</p>
<p>不同版本的SED：不同的版本间的sed会有些不同之处，可以想象它们之间在语法上
会有差异。具体而言，它们中大部分不支持在编辑命令中间使用标签（:name）或分
支命令（b,t），除非是放在那些的末尾。这篇文档中我们尽量选用了可移植性较高
的语法，以使大多数版本的sed的用户都能使用这些脚本。不过GNU版本的sed允许使
用更简洁的语法。想像一下当读者看到一个很长的命令时的心情：</p>
<p>sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d</p>
<p>好消息是GNU sed能让命令更紧凑：</p>
<p>sed '/AAA/b;/BBB/b;/CCC/b;d'      # 甚至可以写成
   sed '/AAA|BBB|CCC/b;d'</p>
<p>此外，请注意虽然许多版本的sed接受象“/one/ s/RE1/RE2/”这种在's'前带有空
格的命令，但这些版本中有些却不接受这样的命令:“/one/! s/RE1/RE2/”。这时
只需要把中间的空格去掉就行了。</p>
<p>速度优化：当由于某种原因（比如输入文件较大、处理器或硬盘较慢等）需要提高
命令执行速度时，可以考虑在替换命令（“s/.../.../”）前面加上地址表达式来
提高速度。举例来说：</p>
<p>sed 's/foo/bar/g' filename         # 标准替换命令
   sed '/foo/ s/foo/bar/g' filename   # 速度更快
   sed '/foo/ s//bar/g' filename      # 简写形式</p>
<p>当只需要显示文件的前面的部分或需要删除后面的内容时，可以在脚本中使用“q”
命令（退出命令）。在处理大的文件时，这会节省大量时间。因此：</p>
<p>sed -n '45,50p' filename           # 显示第45到50行
   sed -n '51q;45,50p' filename       # 一样，但快得多</p>
<p>FILE SPACING:</p>
<p># double space a file
 awk '1;{print ""}'
 awk 'BEGIN{ORS="\n\n"};1'</p>
<p># double space a file which already has blank lines in it. Output file
 # should contain no more than one blank line between lines of text.
 # NOTE: On Unix systems, DOS lines which have only CRLF (\r\n) are
 # often treated as non-blank, and thus 'NF' alone will return TRUE.
 awk 'NF{print $0 "\n"}'</p>
<p># triple space a file
 awk '1;{print "\n"}'</p>
<p>NUMBERING AND CALCULATIONS:</p>
<p># precede each line by its line number FOR THAT FILE (left alignment).
 # Using a tab (\t) instead of space will preserve margins.
 awk '{print FNR "\t" $0}' files*</p>
<p># precede each line by its line number FOR ALL FILES TOGETHER, with tab.
 awk '{print NR "\t" $0}' files*</p>
<p># number each line of a file (number on left, right-aligned)
 # Double the percent signs if typing from the DOS command prompt.
 awk '{printf("%5d : %s\n", NR,$0)}'</p>
<p># number each line of file, but only print numbers if line is not blank
 # Remember caveats about Unix treatment of \r (mentioned above)
 awk 'NF{$0=++a " :" $0};{print}'
 awk '{print (NF? ++a " :" :"") $0}'</p>
<p># count lines (emulates "wc -l")
 awk 'END{print NR}'</p>
<p># print the sums of the fields of every line
 awk '{s=0; for (i=1; i&lt;=NF; i++) s=s+$i; print s}'</p>
<p># add all fields in all lines and print the sum
 awk '{for (i=1; i&lt;=NF; i++) s=s+$i}; END{print s}'</p>
<p># print every line after replacing each field with its absolute value
 awk '{for (i=1; i&lt;=NF; i++) if (<span><span class="MathJax_Preview">i &lt; 0) <span><span class="MathJax_Preview">i = -</span><script type="math/tex">i = -</script></span>i; print }'
 awk '{for (i=1; i&lt;=NF; i++) i; print }'
 awk '{for (i=1; i&lt;=NF; i++) <span><span class="MathJax_Preview">i = (</span><script type="math/tex">i = (</script></span>i &lt; 0) ? -i &lt; 0) ? -</span><script type="math/tex">i < 0) <span><span class="MathJax_Preview">i = -</span><script type="math/tex">i = -</script></span>i; print }'
 awk '{for (i=1; i&lt;=NF; i++) i; print }'
 awk '{for (i=1; i&lt;=NF; i++) <span><span class="MathJax_Preview">i = (</span><script type="math/tex">i = (</script></span>i &lt; 0) ? -i &lt; 0) ? -</script></span>i : $i; print }'</p>
<p># print the total number of fields ("words") in all lines
 awk '{ total = total + NF }; END {print total}' file</p>
<p># print the total number of lines that contain "Beth"
 awk '/Beth/{n++}; END {print n+0}' file</p>
<p># print the largest first field and the line that contains it
 # Intended for finding the longest string in field #1
 awk '<span><span class="MathJax_Preview">1 &gt; max {max=</span><script type="math/tex">1 > max {max=</script></span>1; maxline=$0}; END{ print max, maxline}'</p>
<p># print the number of fields in each line, followed by the line
 awk '{ print NF ":" $0 } '</p>
<p># print the last field of each line
 awk '{ print $NF }'</p>
<p># print the last field of the last line
 awk '{ field = $NF }; END{ print field }'</p>
<p># print every line with more than 4 fields
 awk 'NF &gt; 4'</p>
<p># print every line where the value of the last field is &gt; 4
 awk '$NF &gt; 4'</p>
<p>TEXT CONVERSION AND SUBSTITUTION:</p>
<p># IN UNIX ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format
 awk '{sub(/\r$/,"");print}'   # assumes EACH line ends with Ctrl-M</p>
<p># IN UNIX ENVIRONMENT: convert Unix newlines (LF) to DOS format
 awk '{sub(/$/,"\r");print}</p>
<p># IN DOS ENVIRONMENT: convert Unix newlines (LF) to DOS format
 awk 1</p>
<p># IN DOS ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format
 # Cannot be done with DOS versions of awk, other than gawk:
 gawk -v BINMODE="w" '1' infile &gt;outfile</p>
<p># Use "tr" instead.
 tr -d \r <infile >outfile            # GNU tr version 1.22 or higher</p>
<p># delete leading whitespace (spaces, tabs) from front of each line
 # aligns all text flush left
 awk '{sub(/^[ \t]+/, ""); print}'</p>
<p># delete trailing whitespace (spaces, tabs) from end of each line
 awk '{sub(/[ \t]+$/, "");print}'</p>
<p># delete BOTH leading and trailing whitespace from each line
 awk '{gsub(/^[ \t]+|[ \t]+<span><span class="MathJax_Preview">/,"");print}'
 awk '{</span><script type="math/tex">/,"");print}'
 awk '{</script></span>1=$1;print}'           # also removes extra space between fields</p>
<p># insert 5 blank spaces at beginning of each line (make page offset)
 awk '{sub(/^/, "     ");print}'</p>
<p># align all text flush right on a 79-column width
 awk '{printf "%79s\n", $0}' file*</p>
<p># center all text on a 79-character width
 awk '{l=length();s=int((79-l)/2); printf "%"(s+l)"s\n",$0}' file*</p>
<p># substitute (find and replace) "foo" with "bar" on each line
 awk '{sub(/foo/,"bar");print}'           # replaces only 1<sup>st</sup> instance
 gawk '{$0=gensub(/foo/,"bar",4);print}'  # replaces only 4<sup>th</sup> instance
 awk '{gsub(/foo/,"bar");print}'          # replaces ALL instances in a line</p>
<p># substitute "foo" with "bar" ONLY for lines which contain "baz"
 awk '/baz/{gsub(/foo/, "bar")};{print}'</p>
<p># substitute "foo" with "bar" EXCEPT for lines which contain "baz"
 awk '!/baz/{gsub(/foo/, "bar")};{print}'</p>
<p># change "scarlet" or "ruby" or "puce" to "red"
 awk '{gsub(/scarlet|ruby|puce/, "red"); print}'</p>
<p># reverse order of lines (emulates "tac")
 awk '{a[i++]=$0} END {for (j=i-1; j&gt;=0;) print a[j--] }' file*</p>
<p># if a line ends with a backslash, append the next line to it
 # (fails if there are multiple lines ending with backslash...)
 awk '/\<span><span class="MathJax_Preview">/ {sub(/\\</span><script type="math/tex">/ {sub(/\\</script></span>/,""); getline t; print $0 t; next}; 1' file*</p>
<p># print and sort the login names of all users
 awk -F ":" '{ print $1 | "sort" }' /etc/passwd</p>
<p># print the first 2 fields, in opposite order, of every line
 awk '{print $2, $1}' file</p>
<p># switch the first 2 fields of every line
 awk '{temp = $1; $1 = $2; $2 = temp}' file</p>
<p># print every line, deleting the second field of that line
 awk '{ $2 = ""; print }'</p>
<p># print in reverse order the fields of every line
 awk '{for (i=NF; i&gt;0; i--) printf("%s ",i);printf ("\n")}' file</p>
<p># remove duplicate, consecutive lines (emulates "uniq")
 awk 'a !~ <span><span class="MathJax_Preview">0; {a=</span><script type="math/tex">0; {a=</script></span>0}'</p>
<p># remove duplicate, nonconsecutive lines
 awk '! a[<span><span class="MathJax_Preview">0]++'                     # most concise script
 awk '!(</span><script type="math/tex">0]++'                     # most concise script
 awk '!(</script></span>0 in a) {a[$0];print}'      # most efficient script</p>
<p># concatenate every 5 lines of input, using a comma separator
 # between fields
 awk 'ORS=%NR%5?",":"\n"' file</p>
<p>SELECTIVE PRINTING OF CERTAIN LINES:</p>
<p># print first 10 lines of file (emulates behavior of "head")
 awk 'NR &lt; 11'</p>
<p># print first line of file (emulates "head -1")
 awk 'NR&gt;1{exit};1'</p>
<p># print the last 2 lines of a file (emulates "tail -2")
 awk '{y=x "\n" <span><span class="MathJax_Preview">0; x=</span><script type="math/tex">0; x=</script></span>0};END{print y}'</p>
<p># print the last line of a file (emulates "tail -1")
 awk 'END{print}'</p>
<p># print only lines which match regular expression (emulates "grep")
 awk '/regex/'</p>
<p># print only lines which do NOT match regex (emulates "grep -v")
 awk '!/regex/'</p>
<p># print the line immediately before a regex, but not the line
 # containing the regex
 awk '/regex/{print x};{x=<span><span class="MathJax_Preview">0}'
 awk '/regex/{print (x=="" ? "match on line 1" : x)};{x=</span><script type="math/tex">0}'
 awk '/regex/{print (x=="" ? "match on line 1" : x)};{x=</script></span>0}'</p>
<p># print the line immediately after a regex, but not the line
 # containing the regex
 awk '/regex/{getline;print}'</p>
<p># grep for AAA and BBB and CCC (in any order)
 awk '/AAA/; /BBB/; /CCC/'</p>
<p># grep for AAA and BBB and CCC (in that order)
 awk '/AAA.*BBB.*CCC/'</p>
<p># print only lines of 65 characters or longer
 awk 'length &gt; 64'</p>
<p># print only lines of less than 65 characters
 awk 'length &lt; 64'</p>
<p># print section of file from regular expression to end of file
 awk '/regex/,0'
 awk '/regex/,EOF'</p>
<p># print section of file based on line numbers (lines 8-12, inclusive)
 awk 'NR==8,NR==12'</p>
<p># print line number 52
 awk 'NR==52'
 awk 'NR==52 {print;exit}'          # more efficient on large files</p>
<p># print section of file between two regular expressions (inclusive)
 awk '/Iowa/,/Montana/'             # case sensitive</p>
<p>SELECTIVE DELETION OF CERTAIN LINES:</p>
<p># delete ALL blank lines from a file (same as "grep '.' ")
 awk NF
 awk '/./'</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../BREs/" title="BREs" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  后退
                </span>
                BREs
              </span>
            </div>
          </a>
        
        
          <a href="../Python3/" title="Python3" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  前进
                </span>
                Python3
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/Black-Gold" class="md-footer-social__link fa fa-github"></a>
    
      <a href="https://www.instagram.com/black0gold/" class="md-footer-social__link fa fa-instagram"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.b806dc00.js"></script>
      
        
        
          
          <script src="../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
                <script src="../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../assets/javascripts/lunr/lunr.jp.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
  </body>
</html>